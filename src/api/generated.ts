/**
 * Generated by orval v7.16.1 ğŸº
 * Do not edit manually.
 * NTOU æ‹è³£ç³»çµ± API
 * æµ·å¤§æ‹è³£ç³»çµ±å¾Œç«¯ API æ–‡æª” - æä¾›è¨»å†Šã€ç™»å…¥ã€å•†å“ç®¡ç†ç­‰åŠŸèƒ½
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import * as axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

/**
 * æ›´æ–°å¯†ç¢¼è«‹æ±‚
 */
export interface UpdatePasswordRequest {
  /** ç›®å‰å¯†ç¢¼ */
  currentPassword: string;
  /**
   * æ–°å¯†ç¢¼
   * @minLength 6
   * @maxLength 2147483647
   */
  newPassword: string;
}

/**
 * æ›´æ–°ä½¿ç”¨è€…è³‡è¨Šè«‹æ±‚
 */
export interface UpdateUserRequest {
  /**
   * æ–°çš„ä½¿ç”¨è€…åç¨±ï¼ˆå¯é¸ï¼‰
   * @minLength 3
   * @maxLength 20
   */
  username?: string;
  /** é›»å­éƒµä»¶ï¼ˆå¯é¸ï¼‰ */
  email?: string;
  /**
   * ä½¿ç”¨è€…æš±ç¨±ï¼ˆå¯é¸ï¼‰
   * @minLength 0
   * @maxLength 50
   */
  nickname?: string;
  /**
   * è¯çµ¡åœ°å€ï¼ˆå¯é¸ï¼‰
   * @minLength 0
   * @maxLength 200
   */
  address?: string;
  /**
   * è¯çµ¡é›»è©±ï¼ˆå¯é¸ï¼‰
   * @pattern ^[0-9]{10}$
   */
  phoneNumber?: string;
}

/**
 * ä½¿ç”¨è€…è³‡è¨Šå›æ‡‰
 */
export interface UserInfoResponse {
  /** ä½¿ç”¨è€… ID */
  id?: string;
  /** ä½¿ç”¨è€…åç¨± */
  username?: string;
  /** é›»å­éƒµä»¶ */
  email?: string;
  /** ä½¿ç”¨è€…æš±ç¨± */
  nickname?: string;
  /** åœ°å€ */
  address?: string;
  /** é›»è©±è™Ÿç¢¼ */
  phoneNumber?: string;
  /** å¹³å‡è©•åˆ† */
  averageRating?: number;
  /** è©•åˆ†æ¬¡æ•¸ */
  ratingCount?: number;
}

export type EditProductRequestProductType = typeof EditProductRequestProductType[keyof typeof EditProductRequestProductType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EditProductRequestProductType = {
  DIRECT: 'DIRECT',
  AUCTION: 'AUCTION',
} as const;

export type EditProductRequestProductStatus = typeof EditProductRequestProductStatus[keyof typeof EditProductRequestProductStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EditProductRequestProductStatus = {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  SOLD: 'SOLD',
  BANNED: 'BANNED',
} as const;

export interface EditProductRequest {
  productName?: string;
  productDescription?: string;
  productImage?: string;
  productType?: EditProductRequestProductType;
  productStock?: number;
  productPrice?: number;
  productCategory?: string;
  productStatus?: EditProductRequestProductStatus;
}

export interface UpdateCartQuantityRequest {
  /** @minimum 0 */
  quantity?: number;
}

export type ProductProductType = typeof ProductProductType[keyof typeof ProductProductType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ProductProductType = {
  DIRECT: 'DIRECT',
  AUCTION: 'AUCTION',
} as const;

export type ProductProductStatus = typeof ProductProductStatus[keyof typeof ProductProductStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ProductProductStatus = {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  SOLD: 'SOLD',
  BANNED: 'BANNED',
} as const;

export interface Product {
  productID?: string;
  sellerID?: string;
  productName?: string;
  productType?: ProductProductType;
  productStatus?: ProductProductStatus;
  productDescription?: string;
  viewCount?: number;
  productCategory?: string;
  averageRating?: number;
  reviewCount?: number;
  updatedTime?: string;
  totalSales?: number;
  createdTime?: string;
  productImage?: string;
  nowHighestBid?: number;
  productStock?: number;
  highestBidderID?: string;
  auctionEndTime?: string;
  productPrice?: number;
}

export interface Cart {
  id?: string;
  userId?: string;
  items?: CartItem[];
}

export interface CartItem {
  itemId?: string;
  productId?: string;
  quantity?: number;
}

export type OrderOrderType = typeof OrderOrderType[keyof typeof OrderOrderType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OrderOrderType = {
  DIRECT: 'DIRECT',
  AUCTION: 'AUCTION',
} as const;

export type OrderOrderStatus = typeof OrderOrderStatus[keyof typeof OrderOrderStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OrderOrderStatus = {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  REFUNDED: 'REFUNDED',
} as const;

export interface Order {
  orderID?: string;
  buyerID?: string;
  sellerID?: string;
  cart?: Cart;
  orderTime?: string;
  orderType?: OrderOrderType;
  orderStatus?: OrderOrderStatus;
  orderItems?: OrderItem[];
}

export interface OrderItem {
  productID?: string;
  quantity?: number;
  sellerID?: string;
  price?: number;
  totalPrice?: number;
}

export interface AddToCartRequest {
  productId: string;
  /** @minimum 1 */
  quantity?: number;
}

/**
 * ä½¿ç”¨è€…è¨»å†Šè«‹æ±‚
 */
export interface RegisterRequest {
  /** ä½¿ç”¨è€…åç¨± */
  username: string;
  /** ä½¿ç”¨è€…å¯†ç¢¼ */
  password: string;
  /** é›»å­éƒµä»¶ */
  email: string;
}

/**
 * èªè­‰æˆåŠŸå›æ‡‰
 */
export interface AuthResponse {
  /** JWT Token */
  token?: string;
  /** ä½¿ç”¨è€…åç¨± */
  username?: string;
}

/**
 * ä½¿ç”¨è€…ç™»å…¥è«‹æ±‚
 */
export interface LoginRequest {
  /** ä½¿ç”¨è€…åç¨± */
  username: string;
  /** ä½¿ç”¨è€…å¯†ç¢¼ */
  password: string;
}

/**
 * è³¼ç‰©è»Šé …ç›®è©³ç´°è³‡è¨Š
 */
export interface CartItemDTO {
  /** è³¼ç‰©è»Šé …ç›® ID */
  itemId?: string;
  /** å•†å“ ID */
  productId?: string;
  /** å•†å“åç¨± */
  productName?: string;
  /** å•†å“åƒ¹æ ¼ */
  price?: number;
  /** å•†å“åœ–ç‰‡ URL */
  imageUrl?: string;
  /** è³£å®¶ ID */
  sellerId?: string;
  /** è³£å®¶åç¨± */
  sellerName?: string;
  /** æ•¸é‡ */
  quantity?: number;
  /** å°è¨ˆï¼ˆåƒ¹æ ¼ Ã— æ•¸é‡ï¼‰ */
  subtotal?: number;
}

/**
 * è³¼ç‰©è»Šå®Œæ•´å›æ‡‰
 */
export interface CartResponseDTO {
  /** ä½¿ç”¨è€… ID */
  userId?: string;
  /** è³¼ç‰©è»Šé …ç›®åˆ—è¡¨ */
  items?: CartItemDTO[];
  /** ç¸½é‡‘é¡ */
  totalAmount?: number;
  /** ç¸½é …ç›®æ•¸ */
  totalItems?: number;
}

export type UpdatePassword401 = { [key: string]: unknown };

export type UpdateUser401 = { [key: string]: unknown };

export type CreateOrder200 = { [key: string]: unknown };

export type CreateAuctionParams = {
/**
 * èµ·æ¨™åƒ¹æ ¼
 */
price: number;
/**
 * æ‹è³£çµæŸæ™‚é–“ (ISO 8601 æ ¼å¼)
 */
time: string;
};

export type PlaceBidParams = {
/**
 * å‡ºåƒ¹é‡‘é¡
 */
price: number;
/**
 * å‡ºåƒ¹è€…ID
 */
bidderId: string;
};

export type GetAllProductParams = {
/**
 * é ç¢¼ï¼ˆå¾1é–‹å§‹ï¼‰
 */
page?: number;
/**
 * æ¯é å•†å“æ•¸é‡
 */
pageSize?: number;
};

export type GetOrderById200 = { [key: string]: unknown };

/**
 * æ‰‹å‹•çµæŸæŒ‡å®šå•†å“çš„æ‹è³£ï¼Œæ‹è³£çµæŸå¾Œå°‡ç„¡æ³•å†å‡ºåƒ¹
 * @summary çµæŸæ‹è³£
 */
export const terminateAuction = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.put(
      `/api/${id}/terminate`,undefined,options
    );
  }



export const getTerminateAuctionMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof terminateAuction>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof terminateAuction>>, TError,{id: string}, TContext> => {

const mutationKey = ['terminateAuction'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof terminateAuction>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  terminateAuction(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TerminateAuctionMutationResult = NonNullable<Awaited<ReturnType<typeof terminateAuction>>>
    
    export type TerminateAuctionMutationError = AxiosError<unknown>

    /**
 * @summary çµæŸæ‹è³£
 */
export const useTerminateAuction = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof terminateAuction>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof terminateAuction>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getTerminateAuctionMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * æ›´æ–°ç•¶å‰ä½¿ç”¨è€…çš„å¯†ç¢¼ã€‚éœ€è¦æä¾›ç›®å‰å¯†ç¢¼é€²è¡Œé©—è­‰ã€‚
 * @summary æ›´æ–°ä½¿ç”¨è€…å¯†ç¢¼
 */
export const updatePassword = (
    updatePasswordRequest: UpdatePasswordRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.put(
      `/api/user/password`,
      updatePasswordRequest,options
    );
  }



export const getUpdatePasswordMutationOptions = <TError = AxiosError<UpdatePassword401>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePassword>>, TError,{data: UpdatePasswordRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updatePassword>>, TError,{data: UpdatePasswordRequest}, TContext> => {

const mutationKey = ['updatePassword'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePassword>>, {data: UpdatePasswordRequest}> = (props) => {
          const {data} = props ?? {};

          return  updatePassword(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdatePasswordMutationResult = NonNullable<Awaited<ReturnType<typeof updatePassword>>>
    export type UpdatePasswordMutationBody = UpdatePasswordRequest
    export type UpdatePasswordMutationError = AxiosError<UpdatePassword401>

    /**
 * @summary æ›´æ–°ä½¿ç”¨è€…å¯†ç¢¼
 */
export const useUpdatePassword = <TError = AxiosError<UpdatePassword401>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePassword>>, TError,{data: UpdatePasswordRequest}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updatePassword>>,
        TError,
        {data: UpdatePasswordRequest},
        TContext
      > => {

      const mutationOptions = getUpdatePasswordMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * å–å¾—ç•¶å‰ç™»å…¥ä½¿ç”¨è€…çš„è©³ç´°è³‡è¨Š
 * @summary å–å¾—ç•¶å‰ä½¿ç”¨è€…è³‡è¨Š
 */
export const getCurrentUser = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserInfoResponse>> => {
    
    
    return axios.default.get(
      `/api/user/me`,options
    );
  }




export const getGetCurrentUserQueryKey = () => {
    return [
    `/api/user/me`
    ] as const;
    }

    
export const getGetCurrentUserQueryOptions = <TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = AxiosError<UserInfoResponse>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentUserQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentUser>>> = ({ signal }) => getCurrentUser({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCurrentUserQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentUser>>>
export type GetCurrentUserQueryError = AxiosError<UserInfoResponse>


export function useGetCurrentUser<TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = AxiosError<UserInfoResponse>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentUser>>,
          TError,
          Awaited<ReturnType<typeof getCurrentUser>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentUser<TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = AxiosError<UserInfoResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentUser>>,
          TError,
          Awaited<ReturnType<typeof getCurrentUser>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentUser<TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = AxiosError<UserInfoResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary å–å¾—ç•¶å‰ä½¿ç”¨è€…è³‡è¨Š
 */

export function useGetCurrentUser<TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = AxiosError<UserInfoResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCurrentUserQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * æ›´æ–°ç•¶å‰ä½¿ç”¨è€…çš„è©³ç´°è³‡è¨Šã€‚æ‰€æœ‰æ¬„ä½éƒ½æ˜¯å¯é¸çš„ï¼Œæœªæä¾›çš„æ¬„ä½ä¿æŒä¸è®Šã€‚
 * @summary æ›´æ–°ä½¿ç”¨è€…è³‡è¨Š
 */
export const updateUser = (
    updateUserRequest: UpdateUserRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserInfoResponse>> => {
    
    
    return axios.default.put(
      `/api/user/me`,
      updateUserRequest,options
    );
  }



export const getUpdateUserMutationOptions = <TError = AxiosError<UpdateUser401>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{data: UpdateUserRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{data: UpdateUserRequest}, TContext> => {

const mutationKey = ['updateUser'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUser>>, {data: UpdateUserRequest}> = (props) => {
          const {data} = props ?? {};

          return  updateUser(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateUserMutationResult = NonNullable<Awaited<ReturnType<typeof updateUser>>>
    export type UpdateUserMutationBody = UpdateUserRequest
    export type UpdateUserMutationError = AxiosError<UpdateUser401>

    /**
 * @summary æ›´æ–°ä½¿ç”¨è€…è³‡è¨Š
 */
export const useUpdateUser = <TError = AxiosError<UpdateUser401>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{data: UpdateUserRequest}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateUser>>,
        TError,
        {data: UpdateUserRequest},
        TContext
      > => {

      const mutationOptions = getUpdateUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * å°‡å•†å“ç‹€æ…‹æ”¹ç‚º UNAVAILABLEï¼ˆå·²ä¸‹æ¶ï¼‰ï¼Œå•†å“å°‡ä¸å¯è³¼è²·
 * @summary ä¸‹æ¶å•†å“
 */
export const withdrawProduct = (
    productID: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.put(
      `/api/products/withdraw/${productID}`,undefined,options
    );
  }



export const getWithdrawProductMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof withdrawProduct>>, TError,{productID: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof withdrawProduct>>, TError,{productID: string}, TContext> => {

const mutationKey = ['withdrawProduct'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof withdrawProduct>>, {productID: string}> = (props) => {
          const {productID} = props ?? {};

          return  withdrawProduct(productID,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type WithdrawProductMutationResult = NonNullable<Awaited<ReturnType<typeof withdrawProduct>>>
    
    export type WithdrawProductMutationError = AxiosError<unknown>

    /**
 * @summary ä¸‹æ¶å•†å“
 */
export const useWithdrawProduct = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof withdrawProduct>>, TError,{productID: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof withdrawProduct>>,
        TError,
        {productID: string},
        TContext
      > => {

      const mutationOptions = getWithdrawProductMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * å°‡å•†å“ç‹€æ…‹æ”¹ç‚º AVAILABLEï¼ˆå·²ä¸Šæ¶ï¼‰ï¼Œä½¿å•†å“å¯ä¾›è³¼è²·
 * @summary ä¸Šæ¶å•†å“
 */
export const publishProduct = (
    productID: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.put(
      `/api/products/upload/${productID}`,undefined,options
    );
  }



export const getPublishProductMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof publishProduct>>, TError,{productID: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof publishProduct>>, TError,{productID: string}, TContext> => {

const mutationKey = ['publishProduct'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof publishProduct>>, {productID: string}> = (props) => {
          const {productID} = props ?? {};

          return  publishProduct(productID,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PublishProductMutationResult = NonNullable<Awaited<ReturnType<typeof publishProduct>>>
    
    export type PublishProductMutationError = AxiosError<unknown>

    /**
 * @summary ä¸Šæ¶å•†å“
 */
export const usePublishProduct = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof publishProduct>>, TError,{productID: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof publishProduct>>,
        TError,
        {productID: string},
        TContext
      > => {

      const mutationOptions = getPublishProductMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * æ›´æ–°å•†å“çš„åŸºæœ¬è³‡è¨Šï¼ˆåç¨±ã€åƒ¹æ ¼ã€æè¿°ç­‰ï¼‰
 * @summary ä¿®æ”¹å•†å“è³‡è¨Š
 */
export const editProduct = (
    productID: string,
    editProductRequest: EditProductRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.put(
      `/api/products/edit/${productID}`,
      editProductRequest,options
    );
  }



export const getEditProductMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof editProduct>>, TError,{productID: string;data: EditProductRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof editProduct>>, TError,{productID: string;data: EditProductRequest}, TContext> => {

const mutationKey = ['editProduct'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof editProduct>>, {productID: string;data: EditProductRequest}> = (props) => {
          const {productID,data} = props ?? {};

          return  editProduct(productID,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EditProductMutationResult = NonNullable<Awaited<ReturnType<typeof editProduct>>>
    export type EditProductMutationBody = EditProductRequest
    export type EditProductMutationError = AxiosError<unknown>

    /**
 * @summary ä¿®æ”¹å•†å“è³‡è¨Š
 */
export const useEditProduct = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof editProduct>>, TError,{productID: string;data: EditProductRequest}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof editProduct>>,
        TError,
        {productID: string;data: EditProductRequest},
        TContext
      > => {

      const mutationOptions = getEditProductMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * æ›´æ–°è³¼ç‰©è»Šä¸­æŒ‡å®šé …ç›®çš„æ•¸é‡ï¼Œæ•¸é‡ç‚º 0 æ™‚å°‡ç§»é™¤è©²é …ç›®
 * @summary æ›´æ–°è³¼ç‰©è»Šå•†å“æ•¸é‡
 */
export const updateQuantity = (
    itemId: string,
    updateCartQuantityRequest: UpdateCartQuantityRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    
    return axios.default.put(
      `/api/cart/items/${itemId}`,
      updateCartQuantityRequest,{
    ...options,}
    );
  }



export const getUpdateQuantityMutationOptions = <TError = AxiosError<string>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateQuantity>>, TError,{itemId: string;data: UpdateCartQuantityRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateQuantity>>, TError,{itemId: string;data: UpdateCartQuantityRequest}, TContext> => {

const mutationKey = ['updateQuantity'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateQuantity>>, {itemId: string;data: UpdateCartQuantityRequest}> = (props) => {
          const {itemId,data} = props ?? {};

          return  updateQuantity(itemId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateQuantityMutationResult = NonNullable<Awaited<ReturnType<typeof updateQuantity>>>
    export type UpdateQuantityMutationBody = UpdateCartQuantityRequest
    export type UpdateQuantityMutationError = AxiosError<string>

    /**
 * @summary æ›´æ–°è³¼ç‰©è»Šå•†å“æ•¸é‡
 */
export const useUpdateQuantity = <TError = AxiosError<string>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateQuantity>>, TError,{itemId: string;data: UpdateCartQuantityRequest}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateQuantity>>,
        TError,
        {itemId: string;data: UpdateCartQuantityRequest},
        TContext
      > => {

      const mutationOptions = getUpdateQuantityMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * å¾è³¼ç‰©è»Šä¸­ç§»é™¤æŒ‡å®šçš„é …ç›®
 * @summary å¾è³¼ç‰©è»Šç§»é™¤å•†å“
 */
export const removeFromCart = (
    itemId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    
    return axios.default.delete(
      `/api/cart/items/${itemId}`,{
    ...options,}
    );
  }



export const getRemoveFromCartMutationOptions = <TError = AxiosError<string>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeFromCart>>, TError,{itemId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof removeFromCart>>, TError,{itemId: string}, TContext> => {

const mutationKey = ['removeFromCart'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeFromCart>>, {itemId: string}> = (props) => {
          const {itemId} = props ?? {};

          return  removeFromCart(itemId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveFromCartMutationResult = NonNullable<Awaited<ReturnType<typeof removeFromCart>>>
    
    export type RemoveFromCartMutationError = AxiosError<string>

    /**
 * @summary å¾è³¼ç‰©è»Šç§»é™¤å•†å“
 */
export const useRemoveFromCart = <TError = AxiosError<string>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeFromCart>>, TError,{itemId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof removeFromCart>>,
        TError,
        {itemId: string},
        TContext
      > => {

      const mutationOptions = getRemoveFromCartMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * å»ºç«‹æ–°å•†å“ï¼Œå•†å“é è¨­ç‹€æ…‹ç‚º PENDINGï¼ˆå¾…ä¸Šæ¶ï¼‰
 * @summary æ–°å¢å•†å“
 */
export const createProduct = (
    product: Product, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.post(
      `/api/products/add`,
      product,options
    );
  }



export const getCreateProductMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createProduct>>, TError,{data: Product}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createProduct>>, TError,{data: Product}, TContext> => {

const mutationKey = ['createProduct'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createProduct>>, {data: Product}> = (props) => {
          const {data} = props ?? {};

          return  createProduct(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateProductMutationResult = NonNullable<Awaited<ReturnType<typeof createProduct>>>
    export type CreateProductMutationBody = Product
    export type CreateProductMutationError = AxiosError<unknown>

    /**
 * @summary æ–°å¢å•†å“
 */
export const useCreateProduct = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createProduct>>, TError,{data: Product}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createProduct>>,
        TError,
        {data: Product},
        TContext
      > => {

      const mutationOptions = getCreateProductMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const createOrder = (
    order: Order, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CreateOrder200>> => {
    
    
    return axios.default.post(
      `/api/orders/add`,
      order,options
    );
  }



export const getCreateOrderMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createOrder>>, TError,{data: Order}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createOrder>>, TError,{data: Order}, TContext> => {

const mutationKey = ['createOrder'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createOrder>>, {data: Order}> = (props) => {
          const {data} = props ?? {};

          return  createOrder(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateOrderMutationResult = NonNullable<Awaited<ReturnType<typeof createOrder>>>
    export type CreateOrderMutationBody = Order
    export type CreateOrderMutationError = AxiosError<unknown>

    export const useCreateOrder = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createOrder>>, TError,{data: Order}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createOrder>>,
        TError,
        {data: Order},
        TContext
      > => {

      const mutationOptions = getCreateOrderMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * å°‡å•†å“è¨­å®šç‚ºæ‹è³£æ¨¡å¼ï¼Œéœ€æŒ‡å®šèµ·æ¨™åƒ¹å’ŒçµæŸæ™‚é–“ã€‚æ™‚é–“æ ¼å¼ç‚º ISO 8601 (yyyy-MM-ddTHH:mm:ss)
 * @summary å»ºç«‹æ‹è³£å•†å“
 */
export const createAuction = (
    id: string,
    params: CreateAuctionParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.post(
      `/api/createAucs/${id}`,undefined,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getCreateAuctionMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAuction>>, TError,{id: string;params: CreateAuctionParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createAuction>>, TError,{id: string;params: CreateAuctionParams}, TContext> => {

const mutationKey = ['createAuction'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAuction>>, {id: string;params: CreateAuctionParams}> = (props) => {
          const {id,params} = props ?? {};

          return  createAuction(id,params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAuctionMutationResult = NonNullable<Awaited<ReturnType<typeof createAuction>>>
    
    export type CreateAuctionMutationError = AxiosError<unknown>

    /**
 * @summary å»ºç«‹æ‹è³£å•†å“
 */
export const useCreateAuction = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAuction>>, TError,{id: string;params: CreateAuctionParams}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createAuction>>,
        TError,
        {id: string;params: CreateAuctionParams},
        TContext
      > => {

      const mutationOptions = getCreateAuctionMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * å°‡æŒ‡å®šå•†å“ä»¥æŒ‡å®šæ•¸é‡åŠ å…¥è³¼ç‰©è»Šï¼Œè‹¥å·²å­˜åœ¨å‰‡ç´¯åŠ æ•¸é‡
 * @summary åŠ å…¥å•†å“åˆ°è³¼ç‰©è»Š
 */
export const addToCart = (
    addToCartRequest: AddToCartRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    
    return axios.default.post(
      `/api/cart/items`,
      addToCartRequest,{
    ...options,}
    );
  }



export const getAddToCartMutationOptions = <TError = AxiosError<string>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addToCart>>, TError,{data: AddToCartRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addToCart>>, TError,{data: AddToCartRequest}, TContext> => {

const mutationKey = ['addToCart'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addToCart>>, {data: AddToCartRequest}> = (props) => {
          const {data} = props ?? {};

          return  addToCart(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddToCartMutationResult = NonNullable<Awaited<ReturnType<typeof addToCart>>>
    export type AddToCartMutationBody = AddToCartRequest
    export type AddToCartMutationError = AxiosError<string>

    /**
 * @summary åŠ å…¥å•†å“åˆ°è³¼ç‰©è»Š
 */
export const useAddToCart = <TError = AxiosError<string>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addToCart>>, TError,{data: AddToCartRequest}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addToCart>>,
        TError,
        {data: AddToCartRequest},
        TContext
      > => {

      const mutationOptions = getAddToCartMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * å°æŒ‡å®šå•†å“é€²è¡Œå‡ºåƒ¹ï¼Œå‡ºåƒ¹é‡‘é¡å¿…é ˆé«˜æ–¼ç•¶å‰æœ€é«˜å‡ºåƒ¹
 * @summary ç«¶æ¨™å‡ºåƒ¹
 */
export const placeBid = (
    id: string,
    params: PlaceBidParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.post(
      `/api/bids/${id}`,undefined,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getPlaceBidMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof placeBid>>, TError,{id: string;params: PlaceBidParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof placeBid>>, TError,{id: string;params: PlaceBidParams}, TContext> => {

const mutationKey = ['placeBid'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof placeBid>>, {id: string;params: PlaceBidParams}> = (props) => {
          const {id,params} = props ?? {};

          return  placeBid(id,params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PlaceBidMutationResult = NonNullable<Awaited<ReturnType<typeof placeBid>>>
    
    export type PlaceBidMutationError = AxiosError<unknown>

    /**
 * @summary ç«¶æ¨™å‡ºåƒ¹
 */
export const usePlaceBid = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof placeBid>>, TError,{id: string;params: PlaceBidParams}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof placeBid>>,
        TError,
        {id: string;params: PlaceBidParams},
        TContext
      > => {

      const mutationOptions = getPlaceBidMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * æ–°ä½¿ç”¨è€…è¨»å†Šå¸³è™Ÿã€‚è¨»å†ŠæˆåŠŸå¾Œæœƒè‡ªå‹•ç™»å…¥ä¸¦è¿”å› JWT Tokenã€‚
 * @summary ä½¿ç”¨è€…è¨»å†Š
 */
export const register = (
    registerRequest: RegisterRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AuthResponse>> => {
    
    
    return axios.default.post(
      `/api/auth/register`,
      registerRequest,options
    );
  }



export const getRegisterMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof register>>, TError,{data: RegisterRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof register>>, TError,{data: RegisterRequest}, TContext> => {

const mutationKey = ['register'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof register>>, {data: RegisterRequest}> = (props) => {
          const {data} = props ?? {};

          return  register(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RegisterMutationResult = NonNullable<Awaited<ReturnType<typeof register>>>
    export type RegisterMutationBody = RegisterRequest
    export type RegisterMutationError = AxiosError<unknown>

    /**
 * @summary ä½¿ç”¨è€…è¨»å†Š
 */
export const useRegister = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof register>>, TError,{data: RegisterRequest}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof register>>,
        TError,
        {data: RegisterRequest},
        TContext
      > => {

      const mutationOptions = getRegisterMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ä½¿ç”¨è€…ç™»å…¥ç³»çµ±ã€‚ç™»å…¥æˆåŠŸå¾Œè¿”å› JWT Tokenï¼Œå‰ç«¯éœ€è¦åœ¨å¾ŒçºŒè«‹æ±‚çš„ Authorization Header ä¸­æ”œå¸¶æ­¤ Tokenã€‚
 * @summary ä½¿ç”¨è€…ç™»å…¥
 */
export const login = (
    loginRequest: LoginRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AuthResponse>> => {
    
    
    return axios.default.post(
      `/api/auth/login`,
      loginRequest,options
    );
  }



export const getLoginMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginRequest}, TContext> => {

const mutationKey = ['login'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof login>>, {data: LoginRequest}> = (props) => {
          const {data} = props ?? {};

          return  login(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LoginMutationResult = NonNullable<Awaited<ReturnType<typeof login>>>
    export type LoginMutationBody = LoginRequest
    export type LoginMutationError = AxiosError<unknown>

    /**
 * @summary ä½¿ç”¨è€…ç™»å…¥
 */
export const useLogin = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginRequest}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof login>>,
        TError,
        {data: LoginRequest},
        TContext
      > => {

      const mutationOptions = getLoginMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * åˆ†é æŸ¥è©¢æ‰€æœ‰å•†å“ï¼Œæ”¯æ´è‡ªè¨‚æ¯é å•†å“æ•¸é‡
 * @summary å–å¾—å•†å“åˆ—è¡¨ï¼ˆåˆ†é ï¼‰
 */
export const getAllProduct = (
    params?: GetAllProductParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Product>> => {
    
    
    return axios.default.get(
      `/api/products`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getGetAllProductQueryKey = (params?: GetAllProductParams,) => {
    return [
    `/api/products`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetAllProductQueryOptions = <TData = Awaited<ReturnType<typeof getAllProduct>>, TError = AxiosError<unknown>>(params?: GetAllProductParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllProduct>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllProductQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllProduct>>> = ({ signal }) => getAllProduct(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllProduct>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllProductQueryResult = NonNullable<Awaited<ReturnType<typeof getAllProduct>>>
export type GetAllProductQueryError = AxiosError<unknown>


export function useGetAllProduct<TData = Awaited<ReturnType<typeof getAllProduct>>, TError = AxiosError<unknown>>(
 params: undefined |  GetAllProductParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllProduct>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllProduct>>,
          TError,
          Awaited<ReturnType<typeof getAllProduct>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllProduct<TData = Awaited<ReturnType<typeof getAllProduct>>, TError = AxiosError<unknown>>(
 params?: GetAllProductParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllProduct>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllProduct>>,
          TError,
          Awaited<ReturnType<typeof getAllProduct>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllProduct<TData = Awaited<ReturnType<typeof getAllProduct>>, TError = AxiosError<unknown>>(
 params?: GetAllProductParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllProduct>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary å–å¾—å•†å“åˆ—è¡¨ï¼ˆåˆ†é ï¼‰
 */

export function useGetAllProduct<TData = Awaited<ReturnType<typeof getAllProduct>>, TError = AxiosError<unknown>>(
 params?: GetAllProductParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllProduct>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllProductQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * æ ¹æ“šå•†å“ ID æŸ¥è©¢å•†å“è©³ç´°è³‡è¨Š
 * @summary å–å¾—å–®ä¸€å•†å“è³‡è¨Š
 */
export const getProductById = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Product>> => {
    
    
    return axios.default.get(
      `/api/products/${id}`,options
    );
  }




export const getGetProductByIdQueryKey = (id?: string,) => {
    return [
    `/api/products/${id}`
    ] as const;
    }

    
export const getGetProductByIdQueryOptions = <TData = Awaited<ReturnType<typeof getProductById>>, TError = AxiosError<unknown>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductById>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProductByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductById>>> = ({ signal }) => getProductById(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProductById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProductByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getProductById>>>
export type GetProductByIdQueryError = AxiosError<unknown>


export function useGetProductById<TData = Awaited<ReturnType<typeof getProductById>>, TError = AxiosError<unknown>>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductById>>,
          TError,
          Awaited<ReturnType<typeof getProductById>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProductById<TData = Awaited<ReturnType<typeof getProductById>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductById>>,
          TError,
          Awaited<ReturnType<typeof getProductById>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProductById<TData = Awaited<ReturnType<typeof getProductById>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductById>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary å–å¾—å–®ä¸€å•†å“è³‡è¨Š
 */

export function useGetProductById<TData = Awaited<ReturnType<typeof getProductById>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductById>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetProductByIdQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





export const getOrderById = (
    orderID: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetOrderById200>> => {
    
    
    return axios.default.get(
      `/api/orders/${orderID}`,options
    );
  }




export const getGetOrderByIdQueryKey = (orderID?: string,) => {
    return [
    `/api/orders/${orderID}`
    ] as const;
    }

    
export const getGetOrderByIdQueryOptions = <TData = Awaited<ReturnType<typeof getOrderById>>, TError = AxiosError<unknown>>(orderID: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOrderByIdQueryKey(orderID);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrderById>>> = ({ signal }) => getOrderById(orderID, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(orderID), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOrderByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getOrderById>>>
export type GetOrderByIdQueryError = AxiosError<unknown>


export function useGetOrderById<TData = Awaited<ReturnType<typeof getOrderById>>, TError = AxiosError<unknown>>(
 orderID: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderById>>,
          TError,
          Awaited<ReturnType<typeof getOrderById>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderById<TData = Awaited<ReturnType<typeof getOrderById>>, TError = AxiosError<unknown>>(
 orderID: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderById>>,
          TError,
          Awaited<ReturnType<typeof getOrderById>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderById<TData = Awaited<ReturnType<typeof getOrderById>>, TError = AxiosError<unknown>>(
 orderID: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetOrderById<TData = Awaited<ReturnType<typeof getOrderById>>, TError = AxiosError<unknown>>(
 orderID: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOrderByIdQueryOptions(orderID,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * å–å¾—ç•¶å‰ç™»å…¥ä½¿ç”¨è€…çš„è³¼ç‰©è»Šï¼ŒåŒ…å«å•†å“å®Œæ•´è³‡è¨Šï¼ˆåç¨±ã€åƒ¹æ ¼ã€åœ–ç‰‡ã€è³£å®¶ç­‰ï¼‰
 * @summary å–å¾—è³¼ç‰©è»Š
 */
export const getCart = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CartResponseDTO>> => {
    
    
    return axios.default.get(
      `/api/cart`,options
    );
  }




export const getGetCartQueryKey = () => {
    return [
    `/api/cart`
    ] as const;
    }

    
export const getGetCartQueryOptions = <TData = Awaited<ReturnType<typeof getCart>>, TError = AxiosError<CartResponseDTO>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCart>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCartQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCart>>> = ({ signal }) => getCart({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCart>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCartQueryResult = NonNullable<Awaited<ReturnType<typeof getCart>>>
export type GetCartQueryError = AxiosError<CartResponseDTO>


export function useGetCart<TData = Awaited<ReturnType<typeof getCart>>, TError = AxiosError<CartResponseDTO>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCart>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCart>>,
          TError,
          Awaited<ReturnType<typeof getCart>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCart<TData = Awaited<ReturnType<typeof getCart>>, TError = AxiosError<CartResponseDTO>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCart>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCart>>,
          TError,
          Awaited<ReturnType<typeof getCart>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCart<TData = Awaited<ReturnType<typeof getCart>>, TError = AxiosError<CartResponseDTO>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCart>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary å–å¾—è³¼ç‰©è»Š
 */

export function useGetCart<TData = Awaited<ReturnType<typeof getCart>>, TError = AxiosError<CartResponseDTO>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCart>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCartQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * æ¸…ç©ºç•¶å‰ä½¿ç”¨è€…çš„è³¼ç‰©è»Šï¼Œç§»é™¤æ‰€æœ‰å•†å“
 * @summary æ¸…ç©ºè³¼ç‰©è»Š
 */
export const clearCart = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.delete(
      `/api/cart`,options
    );
  }



export const getClearCartMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof clearCart>>, TError,void, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof clearCart>>, TError,void, TContext> => {

const mutationKey = ['clearCart'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof clearCart>>, void> = () => {
          

          return  clearCart(axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ClearCartMutationResult = NonNullable<Awaited<ReturnType<typeof clearCart>>>
    
    export type ClearCartMutationError = AxiosError<void>

    /**
 * @summary æ¸…ç©ºè³¼ç‰©è»Š
 */
export const useClearCart = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof clearCart>>, TError,void, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof clearCart>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getClearCartMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * æŸ¥è©¢æ‰€æœ‰æ­£åœ¨é€²è¡Œæ‹è³£çš„å•†å“åˆ—è¡¨
 * @summary å–å¾—æ‰€æœ‰æ‹è³£ä¸­çš„å•†å“
 */
export const getAllAuctionProduct = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.get(
      `/api/auctions/`,options
    );
  }




export const getGetAllAuctionProductQueryKey = () => {
    return [
    `/api/auctions/`
    ] as const;
    }

    
export const getGetAllAuctionProductQueryOptions = <TData = Awaited<ReturnType<typeof getAllAuctionProduct>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllAuctionProduct>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllAuctionProductQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllAuctionProduct>>> = ({ signal }) => getAllAuctionProduct({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllAuctionProduct>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllAuctionProductQueryResult = NonNullable<Awaited<ReturnType<typeof getAllAuctionProduct>>>
export type GetAllAuctionProductQueryError = AxiosError<unknown>


export function useGetAllAuctionProduct<TData = Awaited<ReturnType<typeof getAllAuctionProduct>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllAuctionProduct>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllAuctionProduct>>,
          TError,
          Awaited<ReturnType<typeof getAllAuctionProduct>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllAuctionProduct<TData = Awaited<ReturnType<typeof getAllAuctionProduct>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllAuctionProduct>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllAuctionProduct>>,
          TError,
          Awaited<ReturnType<typeof getAllAuctionProduct>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllAuctionProduct<TData = Awaited<ReturnType<typeof getAllAuctionProduct>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllAuctionProduct>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary å–å¾—æ‰€æœ‰æ‹è³£ä¸­çš„å•†å“
 */

export function useGetAllAuctionProduct<TData = Awaited<ReturnType<typeof getAllAuctionProduct>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllAuctionProduct>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllAuctionProductQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * æ°¸ä¹…åˆªé™¤å•†å“è³‡æ–™
 * @summary åˆªé™¤å•†å“
 */
export const deleteProduct = (
    productID: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.delete(
      `/api/products/delete/${productID}`,options
    );
  }



export const getDeleteProductMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteProduct>>, TError,{productID: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteProduct>>, TError,{productID: string}, TContext> => {

const mutationKey = ['deleteProduct'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteProduct>>, {productID: string}> = (props) => {
          const {productID} = props ?? {};

          return  deleteProduct(productID,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteProductMutationResult = NonNullable<Awaited<ReturnType<typeof deleteProduct>>>
    
    export type DeleteProductMutationError = AxiosError<unknown>

    /**
 * @summary åˆªé™¤å•†å“
 */
export const useDeleteProduct = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteProduct>>, TError,{productID: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteProduct>>,
        TError,
        {productID: string},
        TContext
      > => {

      const mutationOptions = getDeleteProductMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
