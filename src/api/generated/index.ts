/**
 * Generated by orval v7.16.1 ğŸº
 * Do not edit manually.
 * NTOU æ‹è³£ç³»çµ± API
 * æµ·å¤§æ‹è³£ç³»çµ±å¾Œç«¯ API æ–‡æª” - æä¾›è¨»å†Šã€ç™»å…¥ã€å•†å“ç®¡ç†ç­‰åŠŸèƒ½
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import * as axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

/**
 * æ›´æ–°å¯†ç¢¼è«‹æ±‚
 */
export interface UpdatePasswordRequest {
  /** ç›®å‰å¯†ç¢¼ */
  currentPassword: string;
  /**
   * æ–°å¯†ç¢¼
   * @minLength 6
   * @maxLength 2147483647
   */
  newPassword: string;
}

/**
 * æ›´æ–°ä½¿ç”¨è€…è³‡è¨Šè«‹æ±‚
 */
export interface UpdateUserRequest {
  /**
   * æ–°çš„ä½¿ç”¨è€…åç¨±ï¼ˆå¯é¸ï¼‰
   * @minLength 3
   * @maxLength 20
   */
  username?: string;
  /** é›»å­éƒµä»¶ï¼ˆå¯é¸ï¼‰ */
  email?: string;
  /**
   * ä½¿ç”¨è€…æš±ç¨±ï¼ˆå¯é¸ï¼‰
   * @minLength 0
   * @maxLength 50
   */
  nickname?: string;
  /**
   * è¯çµ¡åœ°å€ï¼ˆå¯é¸ï¼‰
   * @minLength 0
   * @maxLength 200
   */
  address?: string;
  /**
   * è¯çµ¡é›»è©±ï¼ˆå¯é¸ï¼‰
   * @pattern ^[0-9]{10}$
   */
  phoneNumber?: string;
}

export type ProductProductType = typeof ProductProductType[keyof typeof ProductProductType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ProductProductType = {
  DIRECT: 'DIRECT',
  AUCTION: 'AUCTION',
} as const;

export type ProductProductStatus = typeof ProductProductStatus[keyof typeof ProductProductStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ProductProductStatus = {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  SOLD: 'SOLD',
  BANNED: 'BANNED',
} as const;

export interface Product {
  productID?: string;
  sellerID?: string;
  productName?: string;
  productDescription?: string;
  productPrice?: number;
  productImage?: string;
  productType?: ProductProductType;
  productStock?: number;
  productCategory?: string;
  productStatus?: ProductProductStatus;
  createdTime?: string;
  updatedTime?: string;
  auctionEndTime?: string;
  nowHighestBid?: number;
  highestBidderID?: string;
  viewCount?: number;
  averageRating?: number;
  reviewCount?: number;
  totalSales?: number;
}

/**
 * ä½¿ç”¨è€…è³‡è¨Šå›æ‡‰
 */
export interface UserInfoResponse {
  /** ä½¿ç”¨è€… ID */
  id?: string;
  /** ä½¿ç”¨è€…åç¨± */
  username?: string;
  /** é›»å­éƒµä»¶ */
  email?: string;
  /** ä½¿ç”¨è€…æš±ç¨± */
  nickname?: string;
  /** åœ°å€ */
  address?: string;
  /** é›»è©±è™Ÿç¢¼ */
  phoneNumber?: string;
  /** å¹³å‡è©•åˆ† */
  averageRating?: number;
  /** è©•åˆ†æ¬¡æ•¸ */
  ratingCount?: number;
  /** æ˜¯å¦è¢«å°é– */
  isBanned?: boolean;
  /** æ­£åœ¨è²©å”®çš„å•†å“åˆ—è¡¨ */
  sellingProducts?: Product[];
}

export interface Review {
  userName?: string;
  userID?: string;
  reviewID?: string;
  productID?: string;
  comment?: string;
  createdTime?: string;
  updatedTime?: string;
  imgURL?: string;
  starCount?: number;
}

export interface UpdateCartQuantityRequest {
  /** @minimum 0 */
  quantity?: number;
}

export interface Cart {
  id?: string;
  userId?: string;
  items?: CartItem[];
}

export interface CartItem {
  itemId?: string;
  productId?: string;
  quantity?: number;
}

export type OrderOrderType = typeof OrderOrderType[keyof typeof OrderOrderType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OrderOrderType = {
  DIRECT: 'DIRECT',
  AUCTION: 'AUCTION',
} as const;

export type OrderOrderStatus = typeof OrderOrderStatus[keyof typeof OrderOrderStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OrderOrderStatus = {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  REFUNDED: 'REFUNDED',
} as const;

export interface Order {
  orderID?: string;
  buyerID?: string;
  sellerID?: string;
  cart?: Cart;
  orderTime?: string;
  orderType?: OrderOrderType;
  orderStatus?: OrderOrderStatus;
  orderItems?: OrderItem[];
}

export interface OrderItem {
  productID?: string;
  quantity?: number;
  sellerID?: string;
  price?: number;
  totalPrice?: number;
}

export interface AddToCartRequest {
  productId: string;
  /** @minimum 1 */
  quantity?: number;
}

/**
 * ä½¿ç”¨è€…è¨»å†Šè«‹æ±‚
 */
export interface RegisterRequest {
  /** ä½¿ç”¨è€…åç¨± */
  username: string;
  /** ä½¿ç”¨è€…å¯†ç¢¼ */
  password: string;
  /** é›»å­éƒµä»¶ */
  email: string;
}

/**
 * èªè­‰æˆåŠŸå›æ‡‰
 */
export interface AuthResponse {
  /** JWT Token */
  token?: string;
  /** ä½¿ç”¨è€…åç¨± */
  username?: string;
}

/**
 * ä½¿ç”¨è€…ç™»å…¥è«‹æ±‚
 */
export interface LoginRequest {
  /** ä½¿ç”¨è€…åç¨± */
  username: string;
  /** ä½¿ç”¨è€…å¯†ç¢¼ */
  password: string;
}

/**
 * å…¬é–‹ä½¿ç”¨è€…è³‡è¨Š
 */
export interface PublicUserInfoResponse {
  /** ä½¿ç”¨è€… ID */
  id?: string;
  /** ä½¿ç”¨è€…åç¨± */
  username?: string;
  /** é›»å­éƒµä»¶ */
  email?: string;
  /** ä½¿ç”¨è€…æš±ç¨± */
  nickname?: string;
  /** åœ°å€ */
  address?: string;
  /** é›»è©±è™Ÿç¢¼ */
  phoneNumber?: string;
  /** å¹³å‡è©•åˆ† */
  averageRating?: number;
  /** è©•åˆ†æ¬¡æ•¸ */
  ratingCount?: number;
  /** æ˜¯å¦è¢«å°é– */
  isBanned?: boolean;
  /** æ­£åœ¨è²©å”®çš„å•†å“åˆ—è¡¨ */
  sellingProducts?: Product[];
}

/**
 * æ”¶è—é …ç›®è©³ç´°è³‡è¨Š
 */
export interface FavoriteItemDTO {
  /** å•†å“ ID */
  productId?: string;
  /** å•†å“åç¨± */
  productName?: string;
  /** å•†å“åƒ¹æ ¼ */
  productPrice?: number;
  /** å•†å“åœ–ç‰‡ URL */
  productImage?: string;
  /** å•†å“é¡å‹ */
  productType?: string;
  /** å•†å“ç‹€æ…‹ */
  productStatus?: string;
  /** è³£å®¶ ID */
  sellerId?: string;
  /** è³£å®¶åç¨± */
  sellerName?: string;
  /** åŠ å…¥æ”¶è—çš„æ™‚é–“ */
  addedAt?: string;
}

/**
 * æ”¶è—æ¸…å–®å®Œæ•´å›æ‡‰
 */
export interface FavoriteResponseDTO {
  /** ä½¿ç”¨è€… ID */
  userId?: string;
  /** æ”¶è—é …ç›®åˆ—è¡¨ */
  items?: FavoriteItemDTO[];
  /** ç¸½æ”¶è—æ•¸ */
  totalItems?: number;
}

/**
 * è³¼ç‰©è»Šé …ç›®è©³ç´°è³‡è¨Š
 */
export interface CartItemDTO {
  /** è³¼ç‰©è»Šé …ç›® ID */
  itemId?: string;
  /** å•†å“ ID */
  productId?: string;
  /** å•†å“åç¨± */
  productName?: string;
  /** å•†å“åƒ¹æ ¼ */
  price?: number;
  /** å•†å“åœ–ç‰‡ URL */
  imageUrl?: string;
  /** è³£å®¶ ID */
  sellerId?: string;
  /** è³£å®¶åç¨± */
  sellerName?: string;
  /** æ•¸é‡ */
  quantity?: number;
  /** å°è¨ˆï¼ˆåƒ¹æ ¼ Ã— æ•¸é‡ï¼‰ */
  subtotal?: number;
}

/**
 * è³¼ç‰©è»Šå®Œæ•´å›æ‡‰
 */
export interface CartResponseDTO {
  /** ä½¿ç”¨è€… ID */
  userId?: string;
  /** è³¼ç‰©è»Šé …ç›®åˆ—è¡¨ */
  items?: CartItemDTO[];
  /** ç¸½é‡‘é¡ */
  totalAmount?: number;
  /** ç¸½é …ç›®æ•¸ */
  totalItems?: number;
}

export type UpdatePassword401 = { [key: string]: unknown };

export type UpdateUser401 = { [key: string]: unknown };

export type EditReviewParams = {
/**
 * æ˜Ÿç­‰
 */
starCount: number;
/**
 * è©•è«–å…§å®¹
 */
comment: string;
/**
 * åœ–ç‰‡ URLï¼ˆå¯é¸ï¼‰
 */
imgURL?: string;
};

export type CreateAuctionParams = {
/**
 * èµ·æ¨™åƒ¹æ ¼
 */
price: number;
/**
 * æ‹è³£çµæŸæ™‚é–“ (ISO 8601 æ ¼å¼)
 */
time: string;
};

export type PlaceBidParams = {
/**
 * å‡ºåƒ¹é‡‘é¡
 */
price: number;
/**
 * å‡ºåƒ¹è€…ID
 */
bidderId: string;
};

export type GetUserById404 = { [key: string]: unknown };

export type SearchByKeywordParams = {
/**
 * æœå°‹é—œéµå­— (å•†å“åç¨±)
 */
keyword: string;
};

export type GetAllProductParams = {
/**
 * é ç¢¼ï¼ˆå¾1é–‹å§‹ï¼‰
 */
page?: number;
/**
 * æ¯é å•†å“æ•¸é‡
 */
pageSize?: number;
};

export type GetAllProduct404 = { [key: string]: unknown };

export type GetAllProductsSortedParams = {
/**
 * è¼¸å…¥å•†å“å±¬æ€§ä¸¦é‡å°å…¶ä½œæ’åºï¼Œè¼¸å…¥ä¸å­˜åœ¨çš„å±¬æ€§é è¨­ä¾ç…§åç¨±æ’åº
 */
sortBy?: string;
/**
 * è¼¸å…¥descç‚ºé™åºæ’åºï¼Œè¼¸å…¥å…¶ä»–å€¼å°±ç”¨å‡åºæ’åº
 */
order?: string;
};

export type GetAllProductsSorted200 = { [key: string]: unknown };

export type GetAllProductsSorted404 = { [key: string]: unknown };

export type BlursearchParams = {
/**
 * æœå°‹é—œéµå­— (æ¨¡ç³Šæ¯”å°)
 */
keyword: string;
};

/**
 * æ‰‹å‹•çµæŸæŒ‡å®šå•†å“çš„æ‹è³£ï¼Œæ‹è³£çµæŸå¾Œå°‡ç„¡æ³•å†å‡ºåƒ¹
 * @summary çµæŸæ‹è³£
 */
export const terminateAuction = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.put(
      `/api/${id}/terminate`,undefined,options
    );
  }



export const getTerminateAuctionMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof terminateAuction>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof terminateAuction>>, TError,{id: string}, TContext> => {

const mutationKey = ['terminateAuction'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof terminateAuction>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  terminateAuction(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TerminateAuctionMutationResult = NonNullable<Awaited<ReturnType<typeof terminateAuction>>>
    
    export type TerminateAuctionMutationError = AxiosError<unknown>

    /**
 * @summary çµæŸæ‹è³£
 */
export const useTerminateAuction = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof terminateAuction>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof terminateAuction>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getTerminateAuctionMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * æ›´æ–°ç•¶å‰ä½¿ç”¨è€…çš„å¯†ç¢¼ã€‚éœ€è¦æä¾›ç›®å‰å¯†ç¢¼é€²è¡Œé©—è­‰ã€‚
 * @summary æ›´æ–°ä½¿ç”¨è€…å¯†ç¢¼
 */
export const updatePassword = (
    updatePasswordRequest: UpdatePasswordRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.put(
      `/api/user/password`,
      updatePasswordRequest,options
    );
  }



export const getUpdatePasswordMutationOptions = <TError = AxiosError<UpdatePassword401>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePassword>>, TError,{data: UpdatePasswordRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updatePassword>>, TError,{data: UpdatePasswordRequest}, TContext> => {

const mutationKey = ['updatePassword'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePassword>>, {data: UpdatePasswordRequest}> = (props) => {
          const {data} = props ?? {};

          return  updatePassword(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdatePasswordMutationResult = NonNullable<Awaited<ReturnType<typeof updatePassword>>>
    export type UpdatePasswordMutationBody = UpdatePasswordRequest
    export type UpdatePasswordMutationError = AxiosError<UpdatePassword401>

    /**
 * @summary æ›´æ–°ä½¿ç”¨è€…å¯†ç¢¼
 */
export const useUpdatePassword = <TError = AxiosError<UpdatePassword401>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePassword>>, TError,{data: UpdatePasswordRequest}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updatePassword>>,
        TError,
        {data: UpdatePasswordRequest},
        TContext
      > => {

      const mutationOptions = getUpdatePasswordMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * å–å¾—ç•¶å‰ç™»å…¥ä½¿ç”¨è€…çš„è©³ç´°è³‡è¨Šï¼ŒåŒ…å«æ­£åœ¨è²©å”®çš„å•†å“åˆ—è¡¨
 * @summary å–å¾—ç•¶å‰ä½¿ç”¨è€…è³‡è¨Š
 */
export const getCurrentUser = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserInfoResponse>> => {
    
    
    return axios.default.get(
      `/api/user/me`,options
    );
  }




export const getGetCurrentUserQueryKey = () => {
    return [
    `/api/user/me`
    ] as const;
    }

    
export const getGetCurrentUserQueryOptions = <TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = AxiosError<UserInfoResponse>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentUserQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentUser>>> = ({ signal }) => getCurrentUser({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCurrentUserQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentUser>>>
export type GetCurrentUserQueryError = AxiosError<UserInfoResponse>


export function useGetCurrentUser<TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = AxiosError<UserInfoResponse>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentUser>>,
          TError,
          Awaited<ReturnType<typeof getCurrentUser>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentUser<TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = AxiosError<UserInfoResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentUser>>,
          TError,
          Awaited<ReturnType<typeof getCurrentUser>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentUser<TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = AxiosError<UserInfoResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary å–å¾—ç•¶å‰ä½¿ç”¨è€…è³‡è¨Š
 */

export function useGetCurrentUser<TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = AxiosError<UserInfoResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCurrentUserQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * æ›´æ–°ç•¶å‰ä½¿ç”¨è€…çš„è©³ç´°è³‡è¨Šã€‚æ‰€æœ‰æ¬„ä½éƒ½æ˜¯å¯é¸çš„ï¼Œæœªæä¾›çš„æ¬„ä½ä¿æŒä¸è®Šã€‚
 * @summary æ›´æ–°ä½¿ç”¨è€…è³‡è¨Š
 */
export const updateUser = (
    updateUserRequest: UpdateUserRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserInfoResponse>> => {
    
    
    return axios.default.put(
      `/api/user/me`,
      updateUserRequest,options
    );
  }



export const getUpdateUserMutationOptions = <TError = AxiosError<UpdateUser401>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{data: UpdateUserRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{data: UpdateUserRequest}, TContext> => {

const mutationKey = ['updateUser'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUser>>, {data: UpdateUserRequest}> = (props) => {
          const {data} = props ?? {};

          return  updateUser(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateUserMutationResult = NonNullable<Awaited<ReturnType<typeof updateUser>>>
    export type UpdateUserMutationBody = UpdateUserRequest
    export type UpdateUserMutationError = AxiosError<UpdateUser401>

    /**
 * @summary æ›´æ–°ä½¿ç”¨è€…è³‡è¨Š
 */
export const useUpdateUser = <TError = AxiosError<UpdateUser401>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{data: UpdateUserRequest}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateUser>>,
        TError,
        {data: UpdateUserRequest},
        TContext
      > => {

      const mutationOptions = getUpdateUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ä¾æ“š reviewId ä¿®æ”¹è©•è«–å…§å®¹ã€æ˜Ÿç­‰èˆ‡åœ–ç‰‡ï¼ˆåœ–ç‰‡å¯é¸ï¼‰
 * @summary ä¿®æ”¹è©•è«–
 */
export const editReview = (
    reviewId: string,
    params: EditReviewParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Review>> => {
    
    
    return axios.default.put(
      `/api/reviews/edit/${reviewId}`,undefined,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getEditReviewMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof editReview>>, TError,{reviewId: string;params: EditReviewParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof editReview>>, TError,{reviewId: string;params: EditReviewParams}, TContext> => {

const mutationKey = ['editReview'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof editReview>>, {reviewId: string;params: EditReviewParams}> = (props) => {
          const {reviewId,params} = props ?? {};

          return  editReview(reviewId,params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EditReviewMutationResult = NonNullable<Awaited<ReturnType<typeof editReview>>>
    
    export type EditReviewMutationError = AxiosError<unknown>

    /**
 * @summary ä¿®æ”¹è©•è«–
 */
export const useEditReview = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof editReview>>, TError,{reviewId: string;params: EditReviewParams}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof editReview>>,
        TError,
        {reviewId: string;params: EditReviewParams},
        TContext
      > => {

      const mutationOptions = getEditReviewMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * å°‡å•†å“ç‹€æ…‹æ”¹ç‚º UNAVAILABLEï¼ˆå·²ä¸‹æ¶ï¼‰ï¼Œå•†å“å°‡ä¸å¯è³¼è²·
 * @summary ä¸‹æ¶å•†å“
 */
export const withdrawProduct = (
    productID: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.put(
      `/api/products/withdraw/${productID}`,undefined,options
    );
  }



export const getWithdrawProductMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof withdrawProduct>>, TError,{productID: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof withdrawProduct>>, TError,{productID: string}, TContext> => {

const mutationKey = ['withdrawProduct'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof withdrawProduct>>, {productID: string}> = (props) => {
          const {productID} = props ?? {};

          return  withdrawProduct(productID,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type WithdrawProductMutationResult = NonNullable<Awaited<ReturnType<typeof withdrawProduct>>>
    
    export type WithdrawProductMutationError = AxiosError<unknown>

    /**
 * @summary ä¸‹æ¶å•†å“
 */
export const useWithdrawProduct = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof withdrawProduct>>, TError,{productID: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof withdrawProduct>>,
        TError,
        {productID: string},
        TContext
      > => {

      const mutationOptions = getWithdrawProductMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * å°‡å•†å“ç‹€æ…‹æ”¹ç‚º AVAILABLEï¼ˆå·²ä¸Šæ¶ï¼‰ï¼Œä½¿å•†å“å¯ä¾›è³¼è²·
 * @summary ä¸Šæ¶å•†å“
 */
export const publishProduct = (
    productID: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.put(
      `/api/products/upload/${productID}`,undefined,options
    );
  }



export const getPublishProductMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof publishProduct>>, TError,{productID: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof publishProduct>>, TError,{productID: string}, TContext> => {

const mutationKey = ['publishProduct'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof publishProduct>>, {productID: string}> = (props) => {
          const {productID} = props ?? {};

          return  publishProduct(productID,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PublishProductMutationResult = NonNullable<Awaited<ReturnType<typeof publishProduct>>>
    
    export type PublishProductMutationError = AxiosError<unknown>

    /**
 * @summary ä¸Šæ¶å•†å“
 */
export const usePublishProduct = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof publishProduct>>, TError,{productID: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof publishProduct>>,
        TError,
        {productID: string},
        TContext
      > => {

      const mutationOptions = getPublishProductMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * æ›´æ–°å•†å“çš„åŸºæœ¬è³‡è¨Šï¼ˆåç¨±ã€åƒ¹æ ¼ã€æè¿°ç­‰ï¼‰
 * @summary ä¿®æ”¹å•†å“è³‡è¨Š
 */
export const editProduct = (
    productID: string,
    product: Product, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.put(
      `/api/products/edit/${productID}`,
      product,options
    );
  }



export const getEditProductMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof editProduct>>, TError,{productID: string;data: Product}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof editProduct>>, TError,{productID: string;data: Product}, TContext> => {

const mutationKey = ['editProduct'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof editProduct>>, {productID: string;data: Product}> = (props) => {
          const {productID,data} = props ?? {};

          return  editProduct(productID,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EditProductMutationResult = NonNullable<Awaited<ReturnType<typeof editProduct>>>
    export type EditProductMutationBody = Product
    export type EditProductMutationError = AxiosError<unknown>

    /**
 * @summary ä¿®æ”¹å•†å“è³‡è¨Š
 */
export const useEditProduct = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof editProduct>>, TError,{productID: string;data: Product}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof editProduct>>,
        TError,
        {productID: string;data: Product},
        TContext
      > => {

      const mutationOptions = getEditProductMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary ä¾ç…§è¨‚å–®IDçµå¸³
 */
export const payOrder = (
    orderID: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.put(
      `/api/orders/pay/${orderID}`,undefined,options
    );
  }



export const getPayOrderMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof payOrder>>, TError,{orderID: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof payOrder>>, TError,{orderID: string}, TContext> => {

const mutationKey = ['payOrder'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof payOrder>>, {orderID: string}> = (props) => {
          const {orderID} = props ?? {};

          return  payOrder(orderID,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PayOrderMutationResult = NonNullable<Awaited<ReturnType<typeof payOrder>>>
    
    export type PayOrderMutationError = AxiosError<unknown>

    /**
 * @summary ä¾ç…§è¨‚å–®IDçµå¸³
 */
export const usePayOrder = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof payOrder>>, TError,{orderID: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof payOrder>>,
        TError,
        {orderID: string},
        TContext
      > => {

      const mutationOptions = getPayOrderMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * æ›´æ–°è³¼ç‰©è»Šä¸­æŒ‡å®šé …ç›®çš„æ•¸é‡ï¼Œæ•¸é‡ç‚º 0 æ™‚å°‡ç§»é™¤è©²é …ç›®
 * @summary æ›´æ–°è³¼ç‰©è»Šå•†å“æ•¸é‡
 */
export const updateQuantity = (
    itemId: string,
    updateCartQuantityRequest: UpdateCartQuantityRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    
    return axios.default.put(
      `/api/cart/items/${itemId}`,
      updateCartQuantityRequest,{
    ...options,}
    );
  }



export const getUpdateQuantityMutationOptions = <TError = AxiosError<string>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateQuantity>>, TError,{itemId: string;data: UpdateCartQuantityRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateQuantity>>, TError,{itemId: string;data: UpdateCartQuantityRequest}, TContext> => {

const mutationKey = ['updateQuantity'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateQuantity>>, {itemId: string;data: UpdateCartQuantityRequest}> = (props) => {
          const {itemId,data} = props ?? {};

          return  updateQuantity(itemId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateQuantityMutationResult = NonNullable<Awaited<ReturnType<typeof updateQuantity>>>
    export type UpdateQuantityMutationBody = UpdateCartQuantityRequest
    export type UpdateQuantityMutationError = AxiosError<string>

    /**
 * @summary æ›´æ–°è³¼ç‰©è»Šå•†å“æ•¸é‡
 */
export const useUpdateQuantity = <TError = AxiosError<string>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateQuantity>>, TError,{itemId: string;data: UpdateCartQuantityRequest}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateQuantity>>,
        TError,
        {itemId: string;data: UpdateCartQuantityRequest},
        TContext
      > => {

      const mutationOptions = getUpdateQuantityMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * å¾è³¼ç‰©è»Šä¸­ç§»é™¤æŒ‡å®šçš„é …ç›®
 * @summary å¾è³¼ç‰©è»Šç§»é™¤å•†å“
 */
export const removeFromCart = (
    itemId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    
    return axios.default.delete(
      `/api/cart/items/${itemId}`,{
    ...options,}
    );
  }



export const getRemoveFromCartMutationOptions = <TError = AxiosError<string>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeFromCart>>, TError,{itemId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof removeFromCart>>, TError,{itemId: string}, TContext> => {

const mutationKey = ['removeFromCart'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeFromCart>>, {itemId: string}> = (props) => {
          const {itemId} = props ?? {};

          return  removeFromCart(itemId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveFromCartMutationResult = NonNullable<Awaited<ReturnType<typeof removeFromCart>>>
    
    export type RemoveFromCartMutationError = AxiosError<string>

    /**
 * @summary å¾è³¼ç‰©è»Šç§»é™¤å•†å“
 */
export const useRemoveFromCart = <TError = AxiosError<string>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeFromCart>>, TError,{itemId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof removeFromCart>>,
        TError,
        {itemId: string},
        TContext
      > => {

      const mutationOptions = getRemoveFromCartMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * å»ºç«‹æ–°çš„å•†å“è©•è«–ï¼Œéœ€ç¢ºèªä½¿ç”¨è€…å·²è³¼è²·è©²å•†å“ä¸”æœªè©•è«–é
 * @summary æ–°å¢è©•è«–
 */
export const createReview = (
    review: Review, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Review>> => {
    
    
    return axios.default.post(
      `/api/reviews/add`,
      review,options
    );
  }



export const getCreateReviewMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createReview>>, TError,{data: Review}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createReview>>, TError,{data: Review}, TContext> => {

const mutationKey = ['createReview'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createReview>>, {data: Review}> = (props) => {
          const {data} = props ?? {};

          return  createReview(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateReviewMutationResult = NonNullable<Awaited<ReturnType<typeof createReview>>>
    export type CreateReviewMutationBody = Review
    export type CreateReviewMutationError = AxiosError<unknown>

    /**
 * @summary æ–°å¢è©•è«–
 */
export const useCreateReview = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createReview>>, TError,{data: Review}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createReview>>,
        TError,
        {data: Review},
        TContext
      > => {

      const mutationOptions = getCreateReviewMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * å»ºç«‹æ–°å•†å“ï¼Œå•†å“é è¨­ç‹€æ…‹ç‚º PENDINGï¼ˆå¾…ä¸Šæ¶ï¼‰
 * @summary æ–°å¢å•†å“
 */
export const createProduct = (
    product: Product, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.post(
      `/api/products/add`,
      product,options
    );
  }



export const getCreateProductMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createProduct>>, TError,{data: Product}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createProduct>>, TError,{data: Product}, TContext> => {

const mutationKey = ['createProduct'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createProduct>>, {data: Product}> = (props) => {
          const {data} = props ?? {};

          return  createProduct(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateProductMutationResult = NonNullable<Awaited<ReturnType<typeof createProduct>>>
    export type CreateProductMutationBody = Product
    export type CreateProductMutationError = AxiosError<unknown>

    /**
 * @summary æ–°å¢å•†å“
 */
export const useCreateProduct = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createProduct>>, TError,{data: Product}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createProduct>>,
        TError,
        {data: Product},
        TContext
      > => {

      const mutationOptions = getCreateProductMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary å»ºç«‹è¨‚å–®
 */
export const createOrder = (
    order: Order, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.post(
      `/api/orders/add`,
      order,options
    );
  }



export const getCreateOrderMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createOrder>>, TError,{data: Order}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createOrder>>, TError,{data: Order}, TContext> => {

const mutationKey = ['createOrder'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createOrder>>, {data: Order}> = (props) => {
          const {data} = props ?? {};

          return  createOrder(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateOrderMutationResult = NonNullable<Awaited<ReturnType<typeof createOrder>>>
    export type CreateOrderMutationBody = Order
    export type CreateOrderMutationError = AxiosError<unknown>

    /**
 * @summary å»ºç«‹è¨‚å–®
 */
export const useCreateOrder = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createOrder>>, TError,{data: Order}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createOrder>>,
        TError,
        {data: Order},
        TContext
      > => {

      const mutationOptions = getCreateOrderMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * å°‡æŒ‡å®šå•†å“åŠ å…¥ä½¿ç”¨è€…çš„æ”¶è—æ¸…å–®ï¼ˆç„¡æ”¶è—ä¸Šé™ï¼‰ï¼Œæœƒè‡ªå‹•è¨˜éŒ„åŠ å…¥æ™‚é–“
 * @summary ã€CREATEã€‘åŠ å…¥æ”¶è—æ¸…å–®
 */
export const addToFavorites = (
    userId: string,
    productId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.post(
      `/api/favorites/${userId}/items/${productId}`,undefined,options
    );
  }



export const getAddToFavoritesMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addToFavorites>>, TError,{userId: string;productId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addToFavorites>>, TError,{userId: string;productId: string}, TContext> => {

const mutationKey = ['addToFavorites'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addToFavorites>>, {userId: string;productId: string}> = (props) => {
          const {userId,productId} = props ?? {};

          return  addToFavorites(userId,productId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddToFavoritesMutationResult = NonNullable<Awaited<ReturnType<typeof addToFavorites>>>
    
    export type AddToFavoritesMutationError = AxiosError<unknown>

    /**
 * @summary ã€CREATEã€‘åŠ å…¥æ”¶è—æ¸…å–®
 */
export const useAddToFavorites = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addToFavorites>>, TError,{userId: string;productId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addToFavorites>>,
        TError,
        {userId: string;productId: string},
        TContext
      > => {

      const mutationOptions = getAddToFavoritesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * å¾æ”¶è—æ¸…å–®ä¸­ç§»é™¤æŒ‡å®šå•†å“
 * @summary ã€DELETEã€‘ç§»é™¤æ”¶è—
 */
export const removeFromFavorites = (
    userId: string,
    productId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.delete(
      `/api/favorites/${userId}/items/${productId}`,options
    );
  }



export const getRemoveFromFavoritesMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeFromFavorites>>, TError,{userId: string;productId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof removeFromFavorites>>, TError,{userId: string;productId: string}, TContext> => {

const mutationKey = ['removeFromFavorites'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeFromFavorites>>, {userId: string;productId: string}> = (props) => {
          const {userId,productId} = props ?? {};

          return  removeFromFavorites(userId,productId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveFromFavoritesMutationResult = NonNullable<Awaited<ReturnType<typeof removeFromFavorites>>>
    
    export type RemoveFromFavoritesMutationError = AxiosError<unknown>

    /**
 * @summary ã€DELETEã€‘ç§»é™¤æ”¶è—
 */
export const useRemoveFromFavorites = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeFromFavorites>>, TError,{userId: string;productId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof removeFromFavorites>>,
        TError,
        {userId: string;productId: string},
        TContext
      > => {

      const mutationOptions = getRemoveFromFavoritesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * å°‡å•†å“è¨­å®šç‚ºæ‹è³£æ¨¡å¼ï¼Œéœ€æŒ‡å®šèµ·æ¨™åƒ¹å’ŒçµæŸæ™‚é–“ã€‚æ™‚é–“æ ¼å¼ç‚º ISO 8601 (yyyy-MM-ddTHH:mm:ss)
 * @summary å»ºç«‹æ‹è³£å•†å“
 */
export const createAuction = (
    productID: string,
    params: CreateAuctionParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.post(
      `/api/createAucs/${productID}`,undefined,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getCreateAuctionMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAuction>>, TError,{productID: string;params: CreateAuctionParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createAuction>>, TError,{productID: string;params: CreateAuctionParams}, TContext> => {

const mutationKey = ['createAuction'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAuction>>, {productID: string;params: CreateAuctionParams}> = (props) => {
          const {productID,params} = props ?? {};

          return  createAuction(productID,params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAuctionMutationResult = NonNullable<Awaited<ReturnType<typeof createAuction>>>
    
    export type CreateAuctionMutationError = AxiosError<unknown>

    /**
 * @summary å»ºç«‹æ‹è³£å•†å“
 */
export const useCreateAuction = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAuction>>, TError,{productID: string;params: CreateAuctionParams}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createAuction>>,
        TError,
        {productID: string;params: CreateAuctionParams},
        TContext
      > => {

      const mutationOptions = getCreateAuctionMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * å°‡æŒ‡å®šå•†å“ä»¥æŒ‡å®šæ•¸é‡åŠ å…¥è³¼ç‰©è»Šï¼Œè‹¥å·²å­˜åœ¨å‰‡ç´¯åŠ æ•¸é‡
 * @summary åŠ å…¥å•†å“åˆ°è³¼ç‰©è»Š
 */
export const addToCart = (
    addToCartRequest: AddToCartRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    
    return axios.default.post(
      `/api/cart/items`,
      addToCartRequest,{
    ...options,}
    );
  }



export const getAddToCartMutationOptions = <TError = AxiosError<string>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addToCart>>, TError,{data: AddToCartRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addToCart>>, TError,{data: AddToCartRequest}, TContext> => {

const mutationKey = ['addToCart'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addToCart>>, {data: AddToCartRequest}> = (props) => {
          const {data} = props ?? {};

          return  addToCart(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddToCartMutationResult = NonNullable<Awaited<ReturnType<typeof addToCart>>>
    export type AddToCartMutationBody = AddToCartRequest
    export type AddToCartMutationError = AxiosError<string>

    /**
 * @summary åŠ å…¥å•†å“åˆ°è³¼ç‰©è»Š
 */
export const useAddToCart = <TError = AxiosError<string>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addToCart>>, TError,{data: AddToCartRequest}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addToCart>>,
        TError,
        {data: AddToCartRequest},
        TContext
      > => {

      const mutationOptions = getAddToCartMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * å°æŒ‡å®šå•†å“é€²è¡Œå‡ºåƒ¹ï¼Œå‡ºåƒ¹é‡‘é¡å¿…é ˆé«˜æ–¼ç•¶å‰æœ€é«˜å‡ºåƒ¹ï¼Œæ³¨æ„ä¸‹æ–¹ç¯„ä¾‹IDå·²ç¶“å°æ‡‰åˆ°æ¸¬è©¦ç”¨çš„å•†å“ï¼Œå¯ä»¥æ”¾å¿ƒæ¸¬è©¦
 * @summary ç«¶æ¨™å‡ºåƒ¹
 */
export const placeBid = (
    id: string,
    params: PlaceBidParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.post(
      `/api/bids/${id}`,undefined,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getPlaceBidMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof placeBid>>, TError,{id: string;params: PlaceBidParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof placeBid>>, TError,{id: string;params: PlaceBidParams}, TContext> => {

const mutationKey = ['placeBid'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof placeBid>>, {id: string;params: PlaceBidParams}> = (props) => {
          const {id,params} = props ?? {};

          return  placeBid(id,params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PlaceBidMutationResult = NonNullable<Awaited<ReturnType<typeof placeBid>>>
    
    export type PlaceBidMutationError = AxiosError<unknown>

    /**
 * @summary ç«¶æ¨™å‡ºåƒ¹
 */
export const usePlaceBid = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof placeBid>>, TError,{id: string;params: PlaceBidParams}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof placeBid>>,
        TError,
        {id: string;params: PlaceBidParams},
        TContext
      > => {

      const mutationOptions = getPlaceBidMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * æ–°ä½¿ç”¨è€…è¨»å†Šå¸³è™Ÿã€‚è¨»å†ŠæˆåŠŸå¾Œæœƒè‡ªå‹•ç™»å…¥ä¸¦è¿”å› JWT Tokenã€‚
 * @summary ä½¿ç”¨è€…è¨»å†Š
 */
export const register = (
    registerRequest: RegisterRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AuthResponse>> => {
    
    
    return axios.default.post(
      `/api/auth/register`,
      registerRequest,options
    );
  }



export const getRegisterMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof register>>, TError,{data: RegisterRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof register>>, TError,{data: RegisterRequest}, TContext> => {

const mutationKey = ['register'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof register>>, {data: RegisterRequest}> = (props) => {
          const {data} = props ?? {};

          return  register(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RegisterMutationResult = NonNullable<Awaited<ReturnType<typeof register>>>
    export type RegisterMutationBody = RegisterRequest
    export type RegisterMutationError = AxiosError<unknown>

    /**
 * @summary ä½¿ç”¨è€…è¨»å†Š
 */
export const useRegister = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof register>>, TError,{data: RegisterRequest}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof register>>,
        TError,
        {data: RegisterRequest},
        TContext
      > => {

      const mutationOptions = getRegisterMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ç™»å‡ºç³»çµ±ã€‚ç”±æ–¼ JWT æ˜¯ç„¡ç‹€æ…‹çš„ï¼Œå®¢æˆ¶ç«¯éœ€è¦åˆªé™¤å„²å­˜çš„ Tokenã€‚Token æœƒåœ¨ 30 åˆ†é˜å¾Œè‡ªå‹•éæœŸå¤±æ•ˆã€‚
 * @summary ä½¿ç”¨è€…ç™»å‡º
 */
export const logout = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.post(
      `/api/auth/logout`,undefined,options
    );
  }



export const getLogoutMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,void, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,void, TContext> => {

const mutationKey = ['logout'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof logout>>, void> = () => {
          

          return  logout(axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LogoutMutationResult = NonNullable<Awaited<ReturnType<typeof logout>>>
    
    export type LogoutMutationError = AxiosError<unknown>

    /**
 * @summary ä½¿ç”¨è€…ç™»å‡º
 */
export const useLogout = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,void, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof logout>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getLogoutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ä½¿ç”¨è€…ç™»å…¥ç³»çµ±ã€‚ç™»å…¥æˆåŠŸå¾Œè¿”å› JWT Tokenï¼Œå‰ç«¯éœ€è¦åœ¨å¾ŒçºŒè«‹æ±‚çš„ Authorization Header ä¸­æ”œå¸¶æ­¤ Tokenã€‚
 * @summary ä½¿ç”¨è€…ç™»å…¥
 */
export const login = (
    loginRequest: LoginRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AuthResponse>> => {
    
    
    return axios.default.post(
      `/api/auth/login`,
      loginRequest,options
    );
  }



export const getLoginMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginRequest}, TContext> => {

const mutationKey = ['login'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof login>>, {data: LoginRequest}> = (props) => {
          const {data} = props ?? {};

          return  login(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LoginMutationResult = NonNullable<Awaited<ReturnType<typeof login>>>
    export type LoginMutationBody = LoginRequest
    export type LoginMutationError = AxiosError<unknown>

    /**
 * @summary ä½¿ç”¨è€…ç™»å…¥
 */
export const useLogin = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginRequest}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof login>>,
        TError,
        {data: LoginRequest},
        TContext
      > => {

      const mutationOptions = getLoginMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * æ ¹æ“šä½¿ç”¨è€… ID å–å¾—è©²ä½¿ç”¨è€…çš„å…¬é–‹è³‡è¨Šï¼ŒåŒ…å«æ­£åœ¨è²©å”®çš„å•†å“åˆ—è¡¨ã€‚

**ç”¨é€”**ï¼š
- æŸ¥çœ‹å…¶ä»–ä½¿ç”¨è€…çš„åŸºæœ¬è³‡æ–™
- èŠå¤©åŠŸèƒ½é¡¯ç¤ºå°æ–¹è³‡è¨Š
- å•†å“é é¢é¡¯ç¤ºè³£å®¶è³‡è¨Š
- æŸ¥çœ‹è³£å®¶æ­£åœ¨è²©å”®çš„æ‰€æœ‰å•†å“

**æ³¨æ„**ï¼šæ­¤ API ä¸éœ€è¦ç™»å…¥ï¼Œä¸”ä¸æœƒè¿”å›æ•æ„Ÿè³‡è¨Šï¼ˆå¦‚ emailï¼‰

 * @summary å–å¾—ä½¿ç”¨è€…å…¬é–‹è³‡è¨Š
 */
export const getUserById = (
    userId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PublicUserInfoResponse>> => {
    
    
    return axios.default.get(
      `/api/user/${userId}`,options
    );
  }




export const getGetUserByIdQueryKey = (userId?: string,) => {
    return [
    `/api/user/${userId}`
    ] as const;
    }

    
export const getGetUserByIdQueryOptions = <TData = Awaited<ReturnType<typeof getUserById>>, TError = AxiosError<GetUserById404>>(userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserByIdQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserById>>> = ({ signal }) => getUserById(userId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getUserById>>>
export type GetUserByIdQueryError = AxiosError<GetUserById404>


export function useGetUserById<TData = Awaited<ReturnType<typeof getUserById>>, TError = AxiosError<GetUserById404>>(
 userId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserById>>,
          TError,
          Awaited<ReturnType<typeof getUserById>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserById<TData = Awaited<ReturnType<typeof getUserById>>, TError = AxiosError<GetUserById404>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserById>>,
          TError,
          Awaited<ReturnType<typeof getUserById>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserById<TData = Awaited<ReturnType<typeof getUserById>>, TError = AxiosError<GetUserById404>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary å–å¾—ä½¿ç”¨è€…å…¬é–‹è³‡è¨Š
 */

export function useGetUserById<TData = Awaited<ReturnType<typeof getUserById>>, TError = AxiosError<GetUserById404>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserByIdQueryOptions(userId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * æ ¹æ“šå•†å“åç¨±é€²è¡Œç²¾ç¢ºæœå°‹ï¼Œå•†å“åç¨±éœ€å®Œå…¨ç¬¦åˆ
 * @summary ç²¾ç¢ºæœå°‹å•†å“
 */
export const searchByKeyword = (
    params: SearchByKeywordParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Product>> => {
    
    
    return axios.default.get(
      `/api/search`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getSearchByKeywordQueryKey = (params?: SearchByKeywordParams,) => {
    return [
    `/api/search`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getSearchByKeywordQueryOptions = <TData = Awaited<ReturnType<typeof searchByKeyword>>, TError = AxiosError<unknown>>(params: SearchByKeywordParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchByKeyword>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchByKeywordQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchByKeyword>>> = ({ signal }) => searchByKeyword(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchByKeyword>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SearchByKeywordQueryResult = NonNullable<Awaited<ReturnType<typeof searchByKeyword>>>
export type SearchByKeywordQueryError = AxiosError<unknown>


export function useSearchByKeyword<TData = Awaited<ReturnType<typeof searchByKeyword>>, TError = AxiosError<unknown>>(
 params: SearchByKeywordParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchByKeyword>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchByKeyword>>,
          TError,
          Awaited<ReturnType<typeof searchByKeyword>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchByKeyword<TData = Awaited<ReturnType<typeof searchByKeyword>>, TError = AxiosError<unknown>>(
 params: SearchByKeywordParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchByKeyword>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchByKeyword>>,
          TError,
          Awaited<ReturnType<typeof searchByKeyword>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchByKeyword<TData = Awaited<ReturnType<typeof searchByKeyword>>, TError = AxiosError<unknown>>(
 params: SearchByKeywordParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchByKeyword>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ç²¾ç¢ºæœå°‹å•†å“
 */

export function useSearchByKeyword<TData = Awaited<ReturnType<typeof searchByKeyword>>, TError = AxiosError<unknown>>(
 params: SearchByKeywordParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchByKeyword>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSearchByKeywordQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * å›å‚³ç³»çµ±ä¸­æ‰€æœ‰å•†å“çš„è©•è«–ç´€éŒ„
 * @summary å–å¾—æ‰€æœ‰è©•è«–æ­·å²
 */
export const getAllReviewHistory = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Review>> => {
    
    
    return axios.default.get(
      `/api/reviews/history`,options
    );
  }




export const getGetAllReviewHistoryQueryKey = () => {
    return [
    `/api/reviews/history`
    ] as const;
    }

    
export const getGetAllReviewHistoryQueryOptions = <TData = Awaited<ReturnType<typeof getAllReviewHistory>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllReviewHistory>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllReviewHistoryQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllReviewHistory>>> = ({ signal }) => getAllReviewHistory({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllReviewHistory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllReviewHistoryQueryResult = NonNullable<Awaited<ReturnType<typeof getAllReviewHistory>>>
export type GetAllReviewHistoryQueryError = AxiosError<unknown>


export function useGetAllReviewHistory<TData = Awaited<ReturnType<typeof getAllReviewHistory>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllReviewHistory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllReviewHistory>>,
          TError,
          Awaited<ReturnType<typeof getAllReviewHistory>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllReviewHistory<TData = Awaited<ReturnType<typeof getAllReviewHistory>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllReviewHistory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllReviewHistory>>,
          TError,
          Awaited<ReturnType<typeof getAllReviewHistory>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllReviewHistory<TData = Awaited<ReturnType<typeof getAllReviewHistory>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllReviewHistory>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary å–å¾—æ‰€æœ‰è©•è«–æ­·å²
 */

export function useGetAllReviewHistory<TData = Awaited<ReturnType<typeof getAllReviewHistory>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllReviewHistory>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllReviewHistoryQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * å›å‚³æŒ‡å®šä½¿ç”¨è€…çš„æ‰€æœ‰è©•è«–
 * @summary ä¾ä½¿ç”¨è€…IDå–å¾—è©•è«–
 */
export const getReviewsByUserId = (
    userID: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Review>> => {
    
    
    return axios.default.get(
      `/api/reviews/byUser/${userID}`,options
    );
  }




export const getGetReviewsByUserIdQueryKey = (userID?: string,) => {
    return [
    `/api/reviews/byUser/${userID}`
    ] as const;
    }

    
export const getGetReviewsByUserIdQueryOptions = <TData = Awaited<ReturnType<typeof getReviewsByUserId>>, TError = AxiosError<unknown>>(userID: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewsByUserId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetReviewsByUserIdQueryKey(userID);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getReviewsByUserId>>> = ({ signal }) => getReviewsByUserId(userID, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userID), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getReviewsByUserId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetReviewsByUserIdQueryResult = NonNullable<Awaited<ReturnType<typeof getReviewsByUserId>>>
export type GetReviewsByUserIdQueryError = AxiosError<unknown>


export function useGetReviewsByUserId<TData = Awaited<ReturnType<typeof getReviewsByUserId>>, TError = AxiosError<unknown>>(
 userID: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewsByUserId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReviewsByUserId>>,
          TError,
          Awaited<ReturnType<typeof getReviewsByUserId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetReviewsByUserId<TData = Awaited<ReturnType<typeof getReviewsByUserId>>, TError = AxiosError<unknown>>(
 userID: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewsByUserId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReviewsByUserId>>,
          TError,
          Awaited<ReturnType<typeof getReviewsByUserId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetReviewsByUserId<TData = Awaited<ReturnType<typeof getReviewsByUserId>>, TError = AxiosError<unknown>>(
 userID: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewsByUserId>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ä¾ä½¿ç”¨è€…IDå–å¾—è©•è«–
 */

export function useGetReviewsByUserId<TData = Awaited<ReturnType<typeof getReviewsByUserId>>, TError = AxiosError<unknown>>(
 userID: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewsByUserId>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetReviewsByUserIdQueryOptions(userID,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * å›å‚³æŒ‡å®šå•†å“çš„æ‰€æœ‰è©•è«–
 * @summary ä¾å•†å“IDå–å¾—è©•è«–
 */
export const getReviewsByProductId = (
    productID: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Review>> => {
    
    
    return axios.default.get(
      `/api/reviews/byProduct/${productID}`,options
    );
  }




export const getGetReviewsByProductIdQueryKey = (productID?: string,) => {
    return [
    `/api/reviews/byProduct/${productID}`
    ] as const;
    }

    
export const getGetReviewsByProductIdQueryOptions = <TData = Awaited<ReturnType<typeof getReviewsByProductId>>, TError = AxiosError<unknown>>(productID: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewsByProductId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetReviewsByProductIdQueryKey(productID);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getReviewsByProductId>>> = ({ signal }) => getReviewsByProductId(productID, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(productID), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getReviewsByProductId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetReviewsByProductIdQueryResult = NonNullable<Awaited<ReturnType<typeof getReviewsByProductId>>>
export type GetReviewsByProductIdQueryError = AxiosError<unknown>


export function useGetReviewsByProductId<TData = Awaited<ReturnType<typeof getReviewsByProductId>>, TError = AxiosError<unknown>>(
 productID: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewsByProductId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReviewsByProductId>>,
          TError,
          Awaited<ReturnType<typeof getReviewsByProductId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetReviewsByProductId<TData = Awaited<ReturnType<typeof getReviewsByProductId>>, TError = AxiosError<unknown>>(
 productID: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewsByProductId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReviewsByProductId>>,
          TError,
          Awaited<ReturnType<typeof getReviewsByProductId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetReviewsByProductId<TData = Awaited<ReturnType<typeof getReviewsByProductId>>, TError = AxiosError<unknown>>(
 productID: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewsByProductId>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ä¾å•†å“IDå–å¾—è©•è«–
 */

export function useGetReviewsByProductId<TData = Awaited<ReturnType<typeof getReviewsByProductId>>, TError = AxiosError<unknown>>(
 productID: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewsByProductId>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetReviewsByProductIdQueryOptions(productID,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * åˆ†é æŸ¥è©¢æ‰€æœ‰å•†å“ï¼Œæ”¯æ´è‡ªè¨‚æ¯é å•†å“æ•¸é‡
 * @summary å–å¾—å•†å“åˆ—è¡¨ï¼ˆåˆ†é ï¼‰
 */
export const getAllProduct = (
    params?: GetAllProductParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Product>> => {
    
    
    return axios.default.get(
      `/api/products`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getGetAllProductQueryKey = (params?: GetAllProductParams,) => {
    return [
    `/api/products`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetAllProductQueryOptions = <TData = Awaited<ReturnType<typeof getAllProduct>>, TError = AxiosError<GetAllProduct404>>(params?: GetAllProductParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllProduct>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllProductQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllProduct>>> = ({ signal }) => getAllProduct(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllProduct>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllProductQueryResult = NonNullable<Awaited<ReturnType<typeof getAllProduct>>>
export type GetAllProductQueryError = AxiosError<GetAllProduct404>


export function useGetAllProduct<TData = Awaited<ReturnType<typeof getAllProduct>>, TError = AxiosError<GetAllProduct404>>(
 params: undefined |  GetAllProductParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllProduct>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllProduct>>,
          TError,
          Awaited<ReturnType<typeof getAllProduct>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllProduct<TData = Awaited<ReturnType<typeof getAllProduct>>, TError = AxiosError<GetAllProduct404>>(
 params?: GetAllProductParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllProduct>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllProduct>>,
          TError,
          Awaited<ReturnType<typeof getAllProduct>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllProduct<TData = Awaited<ReturnType<typeof getAllProduct>>, TError = AxiosError<GetAllProduct404>>(
 params?: GetAllProductParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllProduct>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary å–å¾—å•†å“åˆ—è¡¨ï¼ˆåˆ†é ï¼‰
 */

export function useGetAllProduct<TData = Awaited<ReturnType<typeof getAllProduct>>, TError = AxiosError<GetAllProduct404>>(
 params?: GetAllProductParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllProduct>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllProductQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * æ ¹æ“šå•†å“ ID æŸ¥è©¢å•†å“è©³ç´°è³‡è¨Š
 * @summary å–å¾—å–®ä¸€å•†å“è³‡è¨Š
 */
export const getProductById = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Product>> => {
    
    
    return axios.default.get(
      `/api/products/${id}`,options
    );
  }




export const getGetProductByIdQueryKey = (id?: string,) => {
    return [
    `/api/products/${id}`
    ] as const;
    }

    
export const getGetProductByIdQueryOptions = <TData = Awaited<ReturnType<typeof getProductById>>, TError = AxiosError<unknown>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductById>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProductByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductById>>> = ({ signal }) => getProductById(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProductById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProductByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getProductById>>>
export type GetProductByIdQueryError = AxiosError<unknown>


export function useGetProductById<TData = Awaited<ReturnType<typeof getProductById>>, TError = AxiosError<unknown>>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductById>>,
          TError,
          Awaited<ReturnType<typeof getProductById>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProductById<TData = Awaited<ReturnType<typeof getProductById>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductById>>,
          TError,
          Awaited<ReturnType<typeof getProductById>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProductById<TData = Awaited<ReturnType<typeof getProductById>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductById>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary å–å¾—å–®ä¸€å•†å“è³‡è¨Š
 */

export function useGetProductById<TData = Awaited<ReturnType<typeof getProductById>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductById>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetProductByIdQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary å–å¾—æ‰€æœ‰å•†å“ï¼ˆå¯æ’åºï¼‰
 */
export const getAllProductsSorted = (
    params?: GetAllProductsSortedParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetAllProductsSorted200>> => {
    
    
    return axios.default.get(
      `/api/products/sorted`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getGetAllProductsSortedQueryKey = (params?: GetAllProductsSortedParams,) => {
    return [
    `/api/products/sorted`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetAllProductsSortedQueryOptions = <TData = Awaited<ReturnType<typeof getAllProductsSorted>>, TError = AxiosError<GetAllProductsSorted404>>(params?: GetAllProductsSortedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllProductsSorted>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllProductsSortedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllProductsSorted>>> = ({ signal }) => getAllProductsSorted(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllProductsSorted>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllProductsSortedQueryResult = NonNullable<Awaited<ReturnType<typeof getAllProductsSorted>>>
export type GetAllProductsSortedQueryError = AxiosError<GetAllProductsSorted404>


export function useGetAllProductsSorted<TData = Awaited<ReturnType<typeof getAllProductsSorted>>, TError = AxiosError<GetAllProductsSorted404>>(
 params: undefined |  GetAllProductsSortedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllProductsSorted>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllProductsSorted>>,
          TError,
          Awaited<ReturnType<typeof getAllProductsSorted>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllProductsSorted<TData = Awaited<ReturnType<typeof getAllProductsSorted>>, TError = AxiosError<GetAllProductsSorted404>>(
 params?: GetAllProductsSortedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllProductsSorted>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllProductsSorted>>,
          TError,
          Awaited<ReturnType<typeof getAllProductsSorted>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllProductsSorted<TData = Awaited<ReturnType<typeof getAllProductsSorted>>, TError = AxiosError<GetAllProductsSorted404>>(
 params?: GetAllProductsSortedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllProductsSorted>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary å–å¾—æ‰€æœ‰å•†å“ï¼ˆå¯æ’åºï¼‰
 */

export function useGetAllProductsSorted<TData = Awaited<ReturnType<typeof getAllProductsSorted>>, TError = AxiosError<GetAllProductsSorted404>>(
 params?: GetAllProductsSortedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllProductsSorted>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllProductsSortedQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * å›å‚³ç³»çµ±å…§æ‰€æœ‰å•†å“çš„åˆ†é¡åˆ—è¡¨
 * @summary å–å¾—æ‰€æœ‰å•†å“åˆ†é¡
 */
export const getAllCategory = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    
    return axios.default.get(
      `/api/products/Category`,{
    ...options,}
    );
  }




export const getGetAllCategoryQueryKey = () => {
    return [
    `/api/products/Category`
    ] as const;
    }

    
export const getGetAllCategoryQueryOptions = <TData = Awaited<ReturnType<typeof getAllCategory>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllCategory>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllCategoryQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllCategory>>> = ({ signal }) => getAllCategory({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllCategory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllCategoryQueryResult = NonNullable<Awaited<ReturnType<typeof getAllCategory>>>
export type GetAllCategoryQueryError = AxiosError<unknown>


export function useGetAllCategory<TData = Awaited<ReturnType<typeof getAllCategory>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllCategory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllCategory>>,
          TError,
          Awaited<ReturnType<typeof getAllCategory>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllCategory<TData = Awaited<ReturnType<typeof getAllCategory>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllCategory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllCategory>>,
          TError,
          Awaited<ReturnType<typeof getAllCategory>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllCategory<TData = Awaited<ReturnType<typeof getAllCategory>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllCategory>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary å–å¾—æ‰€æœ‰å•†å“åˆ†é¡
 */

export function useGetAllCategory<TData = Awaited<ReturnType<typeof getAllCategory>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllCategory>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllCategoryQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary ä¾ç…§è¨‚å–®IDæœå°‹
 */
export const getOrderById = (
    orderID: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.get(
      `/api/orders/${orderID}`,options
    );
  }




export const getGetOrderByIdQueryKey = (orderID?: string,) => {
    return [
    `/api/orders/${orderID}`
    ] as const;
    }

    
export const getGetOrderByIdQueryOptions = <TData = Awaited<ReturnType<typeof getOrderById>>, TError = AxiosError<unknown>>(orderID: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOrderByIdQueryKey(orderID);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrderById>>> = ({ signal }) => getOrderById(orderID, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(orderID), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOrderByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getOrderById>>>
export type GetOrderByIdQueryError = AxiosError<unknown>


export function useGetOrderById<TData = Awaited<ReturnType<typeof getOrderById>>, TError = AxiosError<unknown>>(
 orderID: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderById>>,
          TError,
          Awaited<ReturnType<typeof getOrderById>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderById<TData = Awaited<ReturnType<typeof getOrderById>>, TError = AxiosError<unknown>>(
 orderID: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderById>>,
          TError,
          Awaited<ReturnType<typeof getOrderById>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderById<TData = Awaited<ReturnType<typeof getOrderById>>, TError = AxiosError<unknown>>(
 orderID: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ä¾ç…§è¨‚å–®IDæœå°‹
 */

export function useGetOrderById<TData = Awaited<ReturnType<typeof getOrderById>>, TError = AxiosError<unknown>>(
 orderID: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOrderByIdQueryOptions(orderID,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * å–å¾—æŒ‡å®šä½¿ç”¨è€…çš„å®Œæ•´æ”¶è—æ¸…å–®ï¼ˆåŒ…å«å•†å“è©³ç´°è³‡è¨Šã€è³£å®¶è³‡è¨Šï¼‰ï¼Œè‡ªå‹•éæ¿¾å·²åˆªé™¤çš„å•†å“
 * @summary ã€READã€‘å–å¾—ä½¿ç”¨è€…æ”¶è—æ¸…å–®
 */
export const getUserFavorites = (
    userId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<FavoriteResponseDTO>> => {
    
    
    return axios.default.get(
      `/api/favorites/${userId}`,options
    );
  }




export const getGetUserFavoritesQueryKey = (userId?: string,) => {
    return [
    `/api/favorites/${userId}`
    ] as const;
    }

    
export const getGetUserFavoritesQueryOptions = <TData = Awaited<ReturnType<typeof getUserFavorites>>, TError = AxiosError<FavoriteResponseDTO>>(userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFavorites>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserFavoritesQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserFavorites>>> = ({ signal }) => getUserFavorites(userId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserFavorites>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserFavoritesQueryResult = NonNullable<Awaited<ReturnType<typeof getUserFavorites>>>
export type GetUserFavoritesQueryError = AxiosError<FavoriteResponseDTO>


export function useGetUserFavorites<TData = Awaited<ReturnType<typeof getUserFavorites>>, TError = AxiosError<FavoriteResponseDTO>>(
 userId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFavorites>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserFavorites>>,
          TError,
          Awaited<ReturnType<typeof getUserFavorites>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserFavorites<TData = Awaited<ReturnType<typeof getUserFavorites>>, TError = AxiosError<FavoriteResponseDTO>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFavorites>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserFavorites>>,
          TError,
          Awaited<ReturnType<typeof getUserFavorites>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserFavorites<TData = Awaited<ReturnType<typeof getUserFavorites>>, TError = AxiosError<FavoriteResponseDTO>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFavorites>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ã€READã€‘å–å¾—ä½¿ç”¨è€…æ”¶è—æ¸…å–®
 */

export function useGetUserFavorites<TData = Awaited<ReturnType<typeof getUserFavorites>>, TError = AxiosError<FavoriteResponseDTO>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFavorites>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserFavoritesQueryOptions(userId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * æ¸…ç©ºä½¿ç”¨è€…çš„æ‰€æœ‰æ”¶è—
 * @summary ã€DELETEã€‘æ¸…ç©ºæ”¶è—æ¸…å–®
 */
export const clearFavorites = (
    userId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.delete(
      `/api/favorites/${userId}`,options
    );
  }



export const getClearFavoritesMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof clearFavorites>>, TError,{userId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof clearFavorites>>, TError,{userId: string}, TContext> => {

const mutationKey = ['clearFavorites'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof clearFavorites>>, {userId: string}> = (props) => {
          const {userId} = props ?? {};

          return  clearFavorites(userId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ClearFavoritesMutationResult = NonNullable<Awaited<ReturnType<typeof clearFavorites>>>
    
    export type ClearFavoritesMutationError = AxiosError<unknown>

    /**
 * @summary ã€DELETEã€‘æ¸…ç©ºæ”¶è—æ¸…å–®
 */
export const useClearFavorites = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof clearFavorites>>, TError,{userId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof clearFavorites>>,
        TError,
        {userId: string},
        TContext
      > => {

      const mutationOptions = getClearFavoritesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * å–å¾—ä½¿ç”¨è€…çš„æ”¶è—å•†å“ç¸½æ•¸ï¼Œå¯ç”¨æ–¼é¡¯ç¤ºæ”¶è—å¾½ç« 
 * @summary ã€READã€‘å–å¾—æ”¶è—æ•¸é‡
 */
export const getFavoritesCount = (
    userId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.get(
      `/api/favorites/${userId}/count`,options
    );
  }




export const getGetFavoritesCountQueryKey = (userId?: string,) => {
    return [
    `/api/favorites/${userId}/count`
    ] as const;
    }

    
export const getGetFavoritesCountQueryOptions = <TData = Awaited<ReturnType<typeof getFavoritesCount>>, TError = AxiosError<unknown>>(userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFavoritesCount>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFavoritesCountQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFavoritesCount>>> = ({ signal }) => getFavoritesCount(userId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getFavoritesCount>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetFavoritesCountQueryResult = NonNullable<Awaited<ReturnType<typeof getFavoritesCount>>>
export type GetFavoritesCountQueryError = AxiosError<unknown>


export function useGetFavoritesCount<TData = Awaited<ReturnType<typeof getFavoritesCount>>, TError = AxiosError<unknown>>(
 userId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFavoritesCount>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFavoritesCount>>,
          TError,
          Awaited<ReturnType<typeof getFavoritesCount>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFavoritesCount<TData = Awaited<ReturnType<typeof getFavoritesCount>>, TError = AxiosError<unknown>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFavoritesCount>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFavoritesCount>>,
          TError,
          Awaited<ReturnType<typeof getFavoritesCount>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFavoritesCount<TData = Awaited<ReturnType<typeof getFavoritesCount>>, TError = AxiosError<unknown>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFavoritesCount>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ã€READã€‘å–å¾—æ”¶è—æ•¸é‡
 */

export function useGetFavoritesCount<TData = Awaited<ReturnType<typeof getFavoritesCount>>, TError = AxiosError<unknown>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFavoritesCount>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetFavoritesCountQueryOptions(userId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * æª¢æŸ¥æŒ‡å®šå•†å“æ˜¯å¦åœ¨ä½¿ç”¨è€…çš„æ”¶è—æ¸…å–®ä¸­ï¼Œå¸¸ç”¨æ–¼å•†å“é é¢é¡¯ç¤ºã€Œå·²æ”¶è—ã€ç‹€æ…‹
 * @summary ã€READã€‘æª¢æŸ¥æ˜¯å¦å·²æ”¶è—
 */
export const isFavorited = (
    userId: string,
    productId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.get(
      `/api/favorites/${userId}/check/${productId}`,options
    );
  }




export const getIsFavoritedQueryKey = (userId?: string,
    productId?: string,) => {
    return [
    `/api/favorites/${userId}/check/${productId}`
    ] as const;
    }

    
export const getIsFavoritedQueryOptions = <TData = Awaited<ReturnType<typeof isFavorited>>, TError = AxiosError<unknown>>(userId: string,
    productId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof isFavorited>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getIsFavoritedQueryKey(userId,productId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof isFavorited>>> = ({ signal }) => isFavorited(userId,productId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId && productId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof isFavorited>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type IsFavoritedQueryResult = NonNullable<Awaited<ReturnType<typeof isFavorited>>>
export type IsFavoritedQueryError = AxiosError<unknown>


export function useIsFavorited<TData = Awaited<ReturnType<typeof isFavorited>>, TError = AxiosError<unknown>>(
 userId: string,
    productId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof isFavorited>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof isFavorited>>,
          TError,
          Awaited<ReturnType<typeof isFavorited>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIsFavorited<TData = Awaited<ReturnType<typeof isFavorited>>, TError = AxiosError<unknown>>(
 userId: string,
    productId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof isFavorited>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof isFavorited>>,
          TError,
          Awaited<ReturnType<typeof isFavorited>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIsFavorited<TData = Awaited<ReturnType<typeof isFavorited>>, TError = AxiosError<unknown>>(
 userId: string,
    productId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof isFavorited>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ã€READã€‘æª¢æŸ¥æ˜¯å¦å·²æ”¶è—
 */

export function useIsFavorited<TData = Awaited<ReturnType<typeof isFavorited>>, TError = AxiosError<unknown>>(
 userId: string,
    productId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof isFavorited>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getIsFavoritedQueryOptions(userId,productId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * å–å¾—ç•¶å‰ç™»å…¥ä½¿ç”¨è€…çš„è³¼ç‰©è»Šï¼ŒåŒ…å«å•†å“å®Œæ•´è³‡è¨Šï¼ˆåç¨±ã€åƒ¹æ ¼ã€åœ–ç‰‡ã€è³£å®¶ç­‰ï¼‰
 * @summary å–å¾—è³¼ç‰©è»Š
 */
export const getCart = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CartResponseDTO>> => {
    
    
    return axios.default.get(
      `/api/cart`,options
    );
  }




export const getGetCartQueryKey = () => {
    return [
    `/api/cart`
    ] as const;
    }

    
export const getGetCartQueryOptions = <TData = Awaited<ReturnType<typeof getCart>>, TError = AxiosError<CartResponseDTO>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCart>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCartQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCart>>> = ({ signal }) => getCart({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCart>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCartQueryResult = NonNullable<Awaited<ReturnType<typeof getCart>>>
export type GetCartQueryError = AxiosError<CartResponseDTO>


export function useGetCart<TData = Awaited<ReturnType<typeof getCart>>, TError = AxiosError<CartResponseDTO>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCart>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCart>>,
          TError,
          Awaited<ReturnType<typeof getCart>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCart<TData = Awaited<ReturnType<typeof getCart>>, TError = AxiosError<CartResponseDTO>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCart>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCart>>,
          TError,
          Awaited<ReturnType<typeof getCart>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCart<TData = Awaited<ReturnType<typeof getCart>>, TError = AxiosError<CartResponseDTO>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCart>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary å–å¾—è³¼ç‰©è»Š
 */

export function useGetCart<TData = Awaited<ReturnType<typeof getCart>>, TError = AxiosError<CartResponseDTO>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCart>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCartQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * æ¸…ç©ºç•¶å‰ä½¿ç”¨è€…çš„è³¼ç‰©è»Šï¼Œç§»é™¤æ‰€æœ‰å•†å“
 * @summary æ¸…ç©ºè³¼ç‰©è»Š
 */
export const clearCart = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.delete(
      `/api/cart`,options
    );
  }



export const getClearCartMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof clearCart>>, TError,void, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof clearCart>>, TError,void, TContext> => {

const mutationKey = ['clearCart'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof clearCart>>, void> = () => {
          

          return  clearCart(axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ClearCartMutationResult = NonNullable<Awaited<ReturnType<typeof clearCart>>>
    
    export type ClearCartMutationError = AxiosError<void>

    /**
 * @summary æ¸…ç©ºè³¼ç‰©è»Š
 */
export const useClearCart = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof clearCart>>, TError,void, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof clearCart>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getClearCartMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * æ ¹æ“šé—œéµå­—é€²è¡Œæ¨¡ç³Šæœå°‹ï¼Œå¯æœå°‹å•†å“åç¨±ã€æè¿°ç­‰ç›¸é—œå…§å®¹
 * @summary æ¨¡ç³Šæœå°‹å•†å“
 */
export const blursearch = (
    params: BlursearchParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Product>> => {
    
    
    return axios.default.get(
      `/api/blursearch`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getBlursearchQueryKey = (params?: BlursearchParams,) => {
    return [
    `/api/blursearch`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getBlursearchQueryOptions = <TData = Awaited<ReturnType<typeof blursearch>>, TError = AxiosError<unknown>>(params: BlursearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof blursearch>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBlursearchQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof blursearch>>> = ({ signal }) => blursearch(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof blursearch>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type BlursearchQueryResult = NonNullable<Awaited<ReturnType<typeof blursearch>>>
export type BlursearchQueryError = AxiosError<unknown>


export function useBlursearch<TData = Awaited<ReturnType<typeof blursearch>>, TError = AxiosError<unknown>>(
 params: BlursearchParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof blursearch>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof blursearch>>,
          TError,
          Awaited<ReturnType<typeof blursearch>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBlursearch<TData = Awaited<ReturnType<typeof blursearch>>, TError = AxiosError<unknown>>(
 params: BlursearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof blursearch>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof blursearch>>,
          TError,
          Awaited<ReturnType<typeof blursearch>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBlursearch<TData = Awaited<ReturnType<typeof blursearch>>, TError = AxiosError<unknown>>(
 params: BlursearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof blursearch>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary æ¨¡ç³Šæœå°‹å•†å“
 */

export function useBlursearch<TData = Awaited<ReturnType<typeof blursearch>>, TError = AxiosError<unknown>>(
 params: BlursearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof blursearch>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getBlursearchQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * æŸ¥è©¢æ‰€æœ‰æ­£åœ¨é€²è¡Œæ‹è³£çš„å•†å“åˆ—è¡¨
 * @summary å–å¾—æ‰€æœ‰æ‹è³£ä¸­çš„å•†å“
 */
export const getAllAuctionProduct = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.get(
      `/api/auctions/`,options
    );
  }




export const getGetAllAuctionProductQueryKey = () => {
    return [
    `/api/auctions/`
    ] as const;
    }

    
export const getGetAllAuctionProductQueryOptions = <TData = Awaited<ReturnType<typeof getAllAuctionProduct>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllAuctionProduct>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllAuctionProductQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllAuctionProduct>>> = ({ signal }) => getAllAuctionProduct({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllAuctionProduct>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllAuctionProductQueryResult = NonNullable<Awaited<ReturnType<typeof getAllAuctionProduct>>>
export type GetAllAuctionProductQueryError = AxiosError<unknown>


export function useGetAllAuctionProduct<TData = Awaited<ReturnType<typeof getAllAuctionProduct>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllAuctionProduct>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllAuctionProduct>>,
          TError,
          Awaited<ReturnType<typeof getAllAuctionProduct>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllAuctionProduct<TData = Awaited<ReturnType<typeof getAllAuctionProduct>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllAuctionProduct>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllAuctionProduct>>,
          TError,
          Awaited<ReturnType<typeof getAllAuctionProduct>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllAuctionProduct<TData = Awaited<ReturnType<typeof getAllAuctionProduct>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllAuctionProduct>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary å–å¾—æ‰€æœ‰æ‹è³£ä¸­çš„å•†å“
 */

export function useGetAllAuctionProduct<TData = Awaited<ReturnType<typeof getAllAuctionProduct>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllAuctionProduct>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllAuctionProductQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * æ°¸ä¹…åˆªé™¤å•†å“è³‡æ–™
 * @summary åˆªé™¤å•†å“
 */
export const deleteProduct = (
    productID: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.delete(
      `/api/products/delete/${productID}`,options
    );
  }



export const getDeleteProductMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteProduct>>, TError,{productID: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteProduct>>, TError,{productID: string}, TContext> => {

const mutationKey = ['deleteProduct'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteProduct>>, {productID: string}> = (props) => {
          const {productID} = props ?? {};

          return  deleteProduct(productID,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteProductMutationResult = NonNullable<Awaited<ReturnType<typeof deleteProduct>>>
    
    export type DeleteProductMutationError = AxiosError<unknown>

    /**
 * @summary åˆªé™¤å•†å“
 */
export const useDeleteProduct = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteProduct>>, TError,{productID: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteProduct>>,
        TError,
        {productID: string},
        TContext
      > => {

      const mutationOptions = getDeleteProductMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
