/**
 * Generated by orval v7.16.1 ğŸº
 * Do not edit manually.
 * NTOU æ‹è³£ç³»çµ± API
 * æµ·å¤§æ‹è³£ç³»çµ±å¾Œç«¯ API æ–‡æª” - æä¾›è¨»å†Šã€ç™»å…¥ã€å•†å“ç®¡ç†ç­‰åŠŸèƒ½
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import * as axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

/**
 * æ›´æ–°å¯†ç¢¼è«‹æ±‚
 */
export interface UpdatePasswordRequest {
  /** ç›®å‰å¯†ç¢¼ */
  currentPassword: string;
  /**
   * æ–°å¯†ç¢¼
   * @minLength 6
   * @maxLength 2147483647
   */
  newPassword: string;
}

/**
 * æ›´æ–°ä½¿ç”¨è€…è³‡è¨Šè«‹æ±‚
 */
export interface UpdateUserRequest {
  /**
   * æ–°çš„ä½¿ç”¨è€…åç¨±ï¼ˆå¯é¸ï¼‰
   * @minLength 3
   * @maxLength 20
   */
  username?: string;
  /** é›»å­éƒµä»¶ï¼ˆå¯é¸ï¼‰ */
  email?: string;
  /**
   * ä½¿ç”¨è€…æš±ç¨±ï¼ˆå¯é¸ï¼‰
   * @minLength 0
   * @maxLength 50
   */
  nickname?: string;
  /**
   * è¯çµ¡åœ°å€ï¼ˆå¯é¸ï¼‰
   * @minLength 0
   * @maxLength 200
   */
  address?: string;
  /**
   * è¯çµ¡é›»è©±ï¼ˆå¯é¸ï¼‰
   * @pattern ^[0-9]{10}$
   */
  phoneNumber?: string;
}

export type ProductProductType = typeof ProductProductType[keyof typeof ProductProductType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ProductProductType = {
  DIRECT: 'DIRECT',
  AUCTION: 'AUCTION',
} as const;

export type ProductProductStatus = typeof ProductProductStatus[keyof typeof ProductProductStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ProductProductStatus = {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  SOLD: 'SOLD',
  BANNED: 'BANNED',
  TERMINATE: 'TERMINATE',
} as const;

export interface Product {
  productID?: string;
  sellerID?: string;
  productName?: string;
  productDescription?: string;
  productPrice?: number;
  productImage?: string;
  productType?: ProductProductType;
  productStock?: number;
  productCategory?: string;
  productStatus?: ProductProductStatus;
  createdTime?: string;
  updatedTime?: string;
  auctionEndTime?: string;
  nowHighestBid?: number;
  highestBidderID?: string;
  viewCount?: number;
  averageRating?: number;
  reviewCount?: number;
  totalSales?: number;
}

/**
 * ä½¿ç”¨è€…è³‡è¨Šå›æ‡‰
 */
export interface UserInfoResponse {
  /** ä½¿ç”¨è€… ID */
  id?: string;
  /** ä½¿ç”¨è€…åç¨± */
  username?: string;
  /** é›»å­éƒµä»¶ */
  email?: string;
  /** ä½¿ç”¨è€…æš±ç¨± */
  nickname?: string;
  /** åœ°å€ */
  address?: string;
  /** é›»è©±è™Ÿç¢¼ */
  phoneNumber?: string;
  /** å¹³å‡è©•åˆ† */
  averageRating?: number;
  /** è©•åˆ†æ¬¡æ•¸ */
  ratingCount?: number;
  /** æ˜¯å¦è¢«å°é– */
  isBanned?: boolean;
  /** æ­£åœ¨è²©å”®çš„å•†å“åˆ—è¡¨ */
  sellingProducts?: Product[];
}

export interface Review {
  userName?: string;
  userID?: string;
  reviewID?: string;
  productID?: string;
  comment?: string;
  createdTime?: string;
  updatedTime?: string;
  imgURL?: string;
  starCount?: number;
}

export interface UpdateCartQuantityRequest {
  /** @minimum 0 */
  quantity?: number;
}

export interface UserCoupon {
  id?: string;
  couponID?: string;
  userId?: string;
  getTime?: string;
  remainingUsage?: number;
  expireTime?: string;
  usedTime?: string;
  orderID?: string;
}

export interface Cart {
  id?: string;
  userId?: string;
  items?: CartItem[];
}

export interface CartItem {
  itemId?: string;
  productId?: string;
  quantity?: number;
}

export type OrderOrderType = typeof OrderOrderType[keyof typeof OrderOrderType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OrderOrderType = {
  DIRECT: 'DIRECT',
  AUCTION: 'AUCTION',
} as const;

export type OrderOrderStatus = typeof OrderOrderStatus[keyof typeof OrderOrderStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OrderOrderStatus = {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  REFUNDED: 'REFUNDED',
} as const;

export interface Order {
  orderID?: string;
  buyerID?: string;
  sellerID?: string;
  cart?: Cart;
  orderTime?: string;
  orderType?: OrderOrderType;
  orderStatus?: OrderOrderStatus;
  totalPrice?: number;
  shippingFee?: number;
  orderItems?: OrderItem[];
}

export interface OrderItem {
  productID?: string;
  quantity?: number;
  sellerID?: string;
  price?: number;
  totalPrice?: number;
}

export interface CreateReviewHistoryRequest {
  reviewID?: string;
  actionType?: string;
}

export interface CreatePurchaseHistoryRequest {
  productQuantity?: number;
  productID?: string[];
}

export interface CreateBrowseHistoryRequest {
  productID?: string;
}

export interface CreateBidHistoryRequest {
  productID?: string;
  bidAmount?: number;
}

export type CouponDiscountType = typeof CouponDiscountType[keyof typeof CouponDiscountType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CouponDiscountType = {
  PERCENT: 'PERCENT',
  FIXED: 'FIXED',
  FREESHIP: 'FREESHIP',
  BUY_ONE_GET_ONE: 'BUY_ONE_GET_ONE',
} as const;

export interface Coupon {
  couponID?: string;
  couponName?: string;
  description?: string;
  expireTime?: string;
  couponCount?: number;
  discountType?: CouponDiscountType;
  discountValue?: number;
  minPurchaseAmount?: number;
  createdTime?: string;
  maxUsage?: number;
}

export interface AddToCartRequest {
  productId: string;
  /** @minimum 1 */
  quantity?: number;
}

/**
 * ä½¿ç”¨è€…è¨»å†Šè«‹æ±‚
 */
export interface RegisterRequest {
  /** ä½¿ç”¨è€…åç¨± */
  username: string;
  /** ä½¿ç”¨è€…å¯†ç¢¼ */
  password: string;
  /** é›»å­éƒµä»¶ */
  email: string;
}

/**
 * èªè­‰æˆåŠŸå›æ‡‰
 */
export interface AuthResponse {
  /** JWT Token */
  token?: string;
  /** ä½¿ç”¨è€…åç¨± */
  username?: string;
}

/**
 * ä½¿ç”¨è€…ç™»å…¥è«‹æ±‚
 */
export interface LoginRequest {
  /** ä½¿ç”¨è€…åç¨± */
  username: string;
  /** ä½¿ç”¨è€…å¯†ç¢¼ */
  password: string;
}

/**
 * å…¬é–‹ä½¿ç”¨è€…è³‡è¨Š
 */
export interface PublicUserInfoResponse {
  /** ä½¿ç”¨è€… ID */
  id?: string;
  /** ä½¿ç”¨è€…åç¨± */
  username?: string;
  /** é›»å­éƒµä»¶ */
  email?: string;
  /** ä½¿ç”¨è€…æš±ç¨± */
  nickname?: string;
  /** åœ°å€ */
  address?: string;
  /** é›»è©±è™Ÿç¢¼ */
  phoneNumber?: string;
  /** å¹³å‡è©•åˆ† */
  averageRating?: number;
  /** è©•åˆ†æ¬¡æ•¸ */
  ratingCount?: number;
  /** æ˜¯å¦è¢«å°é– */
  isBanned?: boolean;
  /** æ­£åœ¨è²©å”®çš„å•†å“åˆ—è¡¨ */
  sellingProducts?: Product[];
}

export interface History {
  _id?: string;
  userID?: string;
  timeStamp?: string;
}

export interface ReviewHistory {
  _id?: string;
  userID?: string;
  timeStamp?: string;
  reviewID?: string;
  actionType?: string;
}

export interface HistoryItem {
  productID?: string;
  sellerID?: string;
  productName?: string;
  productCategory?: string;
  productPrice?: number;
  productQuantity?: number;
  totalPrice?: number;
}

export interface PurchaseHistory {
  _id?: string;
  userID?: string;
  timeStamp?: string;
  ProductID?: string[];
  ProductQuantity?: number;
  historyItems?: HistoryItem[];
  productQuantity?: number;
  productID?: string[];
}

export interface BrowseHistory {
  _id?: string;
  userID?: string;
  timeStamp?: string;
  ProductID?: string;
  historyItem?: HistoryItem;
  productID?: string;
}

export interface BidHistory {
  _id?: string;
  userID?: string;
  timeStamp?: string;
  ProductID?: string;
  bidAmount?: number;
  historyItem?: HistoryItem;
  productID?: string;
}

/**
 * æ”¶è—é …ç›®è©³ç´°è³‡è¨Š
 */
export interface FavoriteItemDTO {
  /** å•†å“ ID */
  productId?: string;
  /** å•†å“åç¨± */
  productName?: string;
  /** å•†å“åƒ¹æ ¼ */
  productPrice?: number;
  /** å•†å“åœ–ç‰‡ URL */
  productImage?: string;
  /** å•†å“é¡å‹ */
  productType?: string;
  /** å•†å“ç‹€æ…‹ */
  productStatus?: string;
  /** è³£å®¶ ID */
  sellerId?: string;
  /** è³£å®¶åç¨± */
  sellerName?: string;
  /** åŠ å…¥æ”¶è—çš„æ™‚é–“ */
  addedAt?: string;
}

/**
 * æ”¶è—æ¸…å–®å®Œæ•´å›æ‡‰
 */
export interface FavoriteResponseDTO {
  /** ä½¿ç”¨è€… ID */
  userId?: string;
  /** æ”¶è—é …ç›®åˆ—è¡¨ */
  items?: FavoriteItemDTO[];
  /** ç¸½æ”¶è—æ•¸ */
  totalItems?: number;
}

/**
 * æ”¶è—é …ç›®ç°¡åŒ–è³‡è¨Š
 */
export interface SimpleFavoriteItemDTO {
  /** å•†å“ ID */
  productId?: string;
  /** åŠ å…¥æ”¶è—çš„æ™‚é–“ */
  addedAt?: string;
}

/**
 * æ”¶è—æ¸…å–®ç°¡åŒ–å›æ‡‰
 */
export interface SimpleFavoriteResponseDTO {
  /** ä½¿ç”¨è€… ID */
  userId?: string;
  /** æ”¶è—å•†å“ ID åˆ—è¡¨ */
  items?: SimpleFavoriteItemDTO[];
  /** ç¸½æ”¶è—æ•¸ */
  totalItems?: number;
}

/**
 * è³¼ç‰©è»Šé …ç›®è©³ç´°è³‡è¨Š
 */
export interface CartItemDTO {
  /** è³¼ç‰©è»Šé …ç›® ID */
  itemId?: string;
  /** å•†å“ ID */
  productId?: string;
  /** å•†å“åç¨± */
  productName?: string;
  /** å•†å“åƒ¹æ ¼ */
  price?: number;
  /** å•†å“åœ–ç‰‡ URL */
  imageUrl?: string;
  /** è³£å®¶ ID */
  sellerId?: string;
  /** è³£å®¶åç¨± */
  sellerName?: string;
  /** æ•¸é‡ */
  quantity?: number;
  /** å°è¨ˆï¼ˆåƒ¹æ ¼ Ã— æ•¸é‡ï¼‰ */
  subtotal?: number;
}

/**
 * è³¼ç‰©è»Šå®Œæ•´å›æ‡‰
 */
export interface CartResponseDTO {
  /** ä½¿ç”¨è€… ID */
  userId?: string;
  /** è³¼ç‰©è»Šé …ç›®åˆ—è¡¨ */
  items?: CartItemDTO[];
  /** ç¸½é‡‘é¡ */
  totalAmount?: number;
  /** ç¸½é …ç›®æ•¸ */
  totalItems?: number;
}

export type UpdatePassword401 = { [key: string]: unknown };

export type UpdateUser401 = { [key: string]: unknown };

export type EditReviewParams = {
/**
 * æ˜Ÿç­‰
 */
starCount: number;
/**
 * è©•è«–å…§å®¹
 */
comment: string;
/**
 * åœ–ç‰‡ URLï¼ˆå¯é¸ï¼‰
 */
imgURL?: string;
};

export type PayOrderParams = {
/**
 * å„ªæƒ åˆ¸IDï¼ˆå¯é¸ï¼‰
 */
couponID?: string;
};

export type MarkCouponUsedParams = {
userCouponId: string;
orderId: string;
};

export type MarkCouponUsed200 = { [key: string]: unknown };

export type MarkCouponUsed400 = { [key: string]: unknown };

export type MarkCouponUsed403 = { [key: string]: unknown };

export type IssueCouponToUserParams = {
/**
 * ä½¿ç”¨è€… ID
 */
userId: string;
/**
 * å„ªæƒ åˆ¸ ID
 */
couponId: string;
};

export type IssueCouponToUser400 = { [key: string]: unknown };

export type IssueCouponToUser403 = { [key: string]: unknown };

export type DrawCouponForUserParams = {
/**
 * ä½¿ç”¨è€… ID
 */
userId: string;
};

export type DrawCouponForUser400 = { [key: string]: unknown };

export type DrawCouponForUser403 = { [key: string]: unknown };

export type ApplyCouponParams = {
/**
 * UserCoupon ID
 */
userCouponId: string;
/**
 * Order ID
 */
orderId: string;
};

export type ApplyCoupon400 = { [key: string]: unknown };

export type ApplyCoupon403 = { [key: string]: unknown };

export type UploadImageBody = {
  /** è¦ä¸Šå‚³çš„åœ–ç‰‡æª”ï¼ˆäºŒé€²ä½ï¼‰ */
  file: Blob;
};

export type CreateReviewHistory200 = { [key: string]: unknown };

export type CreatePurchaseHistory200 = { [key: string]: unknown };

export type CreateBrowseHistory200 = { [key: string]: unknown };

export type CreateBidHistory200 = { [key: string]: unknown };

export type CreateAuctionParams = {
/**
 * èµ·æ¨™åƒ¹æ ¼
 */
price: number;
/**
 * æ‹è³£çµæŸæ™‚é–“ (ISO 8601 æ ¼å¼)
 */
time: string;
};

export type GetAllCoupons404 = { [key: string]: unknown };

export type GetAllCoupons500 = { [key: string]: unknown };

export type CreateCoupon400 = { [key: string]: unknown };

export type CreateCoupon500 = { [key: string]: unknown };

export type PlaceBidParams = {
/**
 * å‡ºåƒ¹é‡‘é¡
 */
price: number;
/**
 * å‡ºåƒ¹è€…ID
 */
bidderId: string;
};

export type GetUserAllCoupons404 = { [key: string]: unknown };

export type GetUserById404 = { [key: string]: unknown };

export type SearchByKeywordParams = {
/**
 * æœå°‹é—œéµå­— (å•†å“åç¨±)
 */
keyword: string;
};

export type GetAllProductParams = {
/**
 * é ç¢¼ï¼ˆå¾1é–‹å§‹ï¼‰
 */
page?: number;
/**
 * æ¯é å•†å“æ•¸é‡
 */
pageSize?: number;
};

export type GetAllProduct404 = { [key: string]: unknown };

export type GetAllProductsSortedParams = {
/**
 * è¼¸å…¥å•†å“å±¬æ€§ä¸¦é‡å°å…¶ä½œæ’åºï¼Œè¼¸å…¥ä¸å­˜åœ¨çš„å±¬æ€§é è¨­ä¾ç…§åç¨±æ’åº
 */
sortBy?: string;
/**
 * è¼¸å…¥descç‚ºé™åºæ’åºï¼Œè¼¸å…¥å…¶ä»–å€¼å°±ç”¨å‡åºæ’åº
 */
order?: string;
};

export type GetAllProductsSorted200 = { [key: string]: unknown };

export type GetAllProductsSorted404 = { [key: string]: unknown };

export type GetHistoryById404 = { [key: string]: unknown };

export type GetHistoryById500 = { [key: string]: unknown };

export type GetAllHistoriesByUserId404 = { [key: string]: unknown };

export type GetAllHistoriesByUserId500 = { [key: string]: unknown };

export type SearchAllHistoriesByProductId404 = { [key: string]: unknown };

export type SearchAllHistoriesByProductId500 = { [key: string]: unknown };

export type GetReviewHistoriesByReviewId404 = { [key: string]: unknown };

export type GetReviewHistoriesByReviewId500 = { [key: string]: unknown };

export type GetReviewHistoriesByUserId404 = { [key: string]: unknown };

export type GetReviewHistoriesByUserId500 = { [key: string]: unknown };

export type GetPurchaseHistoriesByUserId404 = { [key: string]: unknown };

export type GetPurchaseHistoriesByUserId500 = { [key: string]: unknown };

export type GetPurchaseHistoriesByProductId404 = { [key: string]: unknown };

export type GetPurchaseHistoriesByProductId500 = { [key: string]: unknown };

export type GetBrowseHistoriesByUserId404 = { [key: string]: unknown };

export type GetBrowseHistoriesByUserId500 = { [key: string]: unknown };

export type GetBrowseHistoriesByProductId404 = { [key: string]: unknown };

export type GetBrowseHistoriesByProductId500 = { [key: string]: unknown };

export type GetBidHistoriesByUserId404 = { [key: string]: unknown };

export type GetBidHistoriesByUserId500 = { [key: string]: unknown };

export type GetBidHistoriesByProductId404 = { [key: string]: unknown };

export type GetBidHistoriesByProductId500 = { [key: string]: unknown };

export type GetCouponById404 = { [key: string]: unknown };

export type GetCouponById500 = { [key: string]: unknown };

export type DeleteCoupon200 = { [key: string]: unknown };

export type DeleteCoupon404 = { [key: string]: unknown };

export type DeleteCoupon500 = { [key: string]: unknown };

export type BlursearchParams = {
/**
 * æœå°‹é—œéµå­— (æ¨¡ç³Šæ¯”å°)
 */
keyword: string;
};

export type DeleteUserCoupon200 = { [key: string]: unknown };

export type DeleteUserCoupon403 = { [key: string]: unknown };

export type DeleteUserCoupon404 = { [key: string]: unknown };

/**
 * æ‰‹å‹•çµæŸæŒ‡å®šå•†å“çš„æ‹è³£ï¼Œæ‹è³£çµæŸå¾Œå°‡ç„¡æ³•å†å‡ºåƒ¹
 * @summary çµæŸæ‹è³£
 */
export const terminateAuction = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.put(
      `/api/${id}/terminate`,undefined,options
    );
  }



export const getTerminateAuctionMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof terminateAuction>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof terminateAuction>>, TError,{id: string}, TContext> => {

const mutationKey = ['terminateAuction'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof terminateAuction>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  terminateAuction(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TerminateAuctionMutationResult = NonNullable<Awaited<ReturnType<typeof terminateAuction>>>
    
    export type TerminateAuctionMutationError = AxiosError<unknown>

    /**
 * @summary çµæŸæ‹è³£
 */
export const useTerminateAuction = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof terminateAuction>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof terminateAuction>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getTerminateAuctionMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * æ›´æ–°ç•¶å‰ä½¿ç”¨è€…çš„å¯†ç¢¼ã€‚éœ€è¦æä¾›ç›®å‰å¯†ç¢¼é€²è¡Œé©—è­‰ã€‚
 * @summary æ›´æ–°ä½¿ç”¨è€…å¯†ç¢¼
 */
export const updatePassword = (
    updatePasswordRequest: UpdatePasswordRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.put(
      `/api/user/password`,
      updatePasswordRequest,options
    );
  }



export const getUpdatePasswordMutationOptions = <TError = AxiosError<UpdatePassword401>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePassword>>, TError,{data: UpdatePasswordRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updatePassword>>, TError,{data: UpdatePasswordRequest}, TContext> => {

const mutationKey = ['updatePassword'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePassword>>, {data: UpdatePasswordRequest}> = (props) => {
          const {data} = props ?? {};

          return  updatePassword(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdatePasswordMutationResult = NonNullable<Awaited<ReturnType<typeof updatePassword>>>
    export type UpdatePasswordMutationBody = UpdatePasswordRequest
    export type UpdatePasswordMutationError = AxiosError<UpdatePassword401>

    /**
 * @summary æ›´æ–°ä½¿ç”¨è€…å¯†ç¢¼
 */
export const useUpdatePassword = <TError = AxiosError<UpdatePassword401>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePassword>>, TError,{data: UpdatePasswordRequest}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updatePassword>>,
        TError,
        {data: UpdatePasswordRequest},
        TContext
      > => {

      const mutationOptions = getUpdatePasswordMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * å–å¾—ç•¶å‰ç™»å…¥ä½¿ç”¨è€…çš„è©³ç´°è³‡è¨Šï¼ŒåŒ…å«æ­£åœ¨è²©å”®çš„å•†å“åˆ—è¡¨
 * @summary å–å¾—ç•¶å‰ä½¿ç”¨è€…è³‡è¨Š
 */
export const getCurrentUser = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserInfoResponse>> => {
    
    
    return axios.default.get(
      `/api/user/me`,options
    );
  }




export const getGetCurrentUserQueryKey = () => {
    return [
    `/api/user/me`
    ] as const;
    }

    
export const getGetCurrentUserQueryOptions = <TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = AxiosError<UserInfoResponse>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentUserQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentUser>>> = ({ signal }) => getCurrentUser({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCurrentUserQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentUser>>>
export type GetCurrentUserQueryError = AxiosError<UserInfoResponse>


export function useGetCurrentUser<TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = AxiosError<UserInfoResponse>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentUser>>,
          TError,
          Awaited<ReturnType<typeof getCurrentUser>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentUser<TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = AxiosError<UserInfoResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentUser>>,
          TError,
          Awaited<ReturnType<typeof getCurrentUser>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentUser<TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = AxiosError<UserInfoResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary å–å¾—ç•¶å‰ä½¿ç”¨è€…è³‡è¨Š
 */

export function useGetCurrentUser<TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = AxiosError<UserInfoResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCurrentUserQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * æ›´æ–°ç•¶å‰ä½¿ç”¨è€…çš„è©³ç´°è³‡è¨Šã€‚æ‰€æœ‰æ¬„ä½éƒ½æ˜¯å¯é¸çš„ï¼Œæœªæä¾›çš„æ¬„ä½ä¿æŒä¸è®Šã€‚
 * @summary æ›´æ–°ä½¿ç”¨è€…è³‡è¨Š
 */
export const updateUser = (
    updateUserRequest: UpdateUserRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserInfoResponse>> => {
    
    
    return axios.default.put(
      `/api/user/me`,
      updateUserRequest,options
    );
  }



export const getUpdateUserMutationOptions = <TError = AxiosError<UpdateUser401>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{data: UpdateUserRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{data: UpdateUserRequest}, TContext> => {

const mutationKey = ['updateUser'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUser>>, {data: UpdateUserRequest}> = (props) => {
          const {data} = props ?? {};

          return  updateUser(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateUserMutationResult = NonNullable<Awaited<ReturnType<typeof updateUser>>>
    export type UpdateUserMutationBody = UpdateUserRequest
    export type UpdateUserMutationError = AxiosError<UpdateUser401>

    /**
 * @summary æ›´æ–°ä½¿ç”¨è€…è³‡è¨Š
 */
export const useUpdateUser = <TError = AxiosError<UpdateUser401>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{data: UpdateUserRequest}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateUser>>,
        TError,
        {data: UpdateUserRequest},
        TContext
      > => {

      const mutationOptions = getUpdateUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ä¾æ“š reviewId ä¿®æ”¹è©•è«–å…§å®¹ã€æ˜Ÿç­‰èˆ‡åœ–ç‰‡ï¼ˆåœ–ç‰‡å¯é¸ï¼‰
 * @summary ä¿®æ”¹è©•è«–
 */
export const editReview = (
    reviewId: string,
    params: EditReviewParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Review>> => {
    
    
    return axios.default.put(
      `/api/reviews/edit/${reviewId}`,undefined,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getEditReviewMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof editReview>>, TError,{reviewId: string;params: EditReviewParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof editReview>>, TError,{reviewId: string;params: EditReviewParams}, TContext> => {

const mutationKey = ['editReview'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof editReview>>, {reviewId: string;params: EditReviewParams}> = (props) => {
          const {reviewId,params} = props ?? {};

          return  editReview(reviewId,params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EditReviewMutationResult = NonNullable<Awaited<ReturnType<typeof editReview>>>
    
    export type EditReviewMutationError = AxiosError<unknown>

    /**
 * @summary ä¿®æ”¹è©•è«–
 */
export const useEditReview = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof editReview>>, TError,{reviewId: string;params: EditReviewParams}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof editReview>>,
        TError,
        {reviewId: string;params: EditReviewParams},
        TContext
      > => {

      const mutationOptions = getEditReviewMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * å°‡å•†å“ç‹€æ…‹æ”¹ç‚º UNAVAILABLEï¼ˆå·²ä¸‹æ¶ï¼‰ï¼Œå•†å“å°‡ä¸å¯è³¼è²·
 * @summary ä¸‹æ¶å•†å“
 */
export const withdrawProduct = (
    productID: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.put(
      `/api/products/withdraw/${productID}`,undefined,options
    );
  }



export const getWithdrawProductMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof withdrawProduct>>, TError,{productID: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof withdrawProduct>>, TError,{productID: string}, TContext> => {

const mutationKey = ['withdrawProduct'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof withdrawProduct>>, {productID: string}> = (props) => {
          const {productID} = props ?? {};

          return  withdrawProduct(productID,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type WithdrawProductMutationResult = NonNullable<Awaited<ReturnType<typeof withdrawProduct>>>
    
    export type WithdrawProductMutationError = AxiosError<unknown>

    /**
 * @summary ä¸‹æ¶å•†å“
 */
export const useWithdrawProduct = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof withdrawProduct>>, TError,{productID: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof withdrawProduct>>,
        TError,
        {productID: string},
        TContext
      > => {

      const mutationOptions = getWithdrawProductMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * å°‡å•†å“ç‹€æ…‹æ”¹ç‚º AVAILABLEï¼ˆå·²ä¸Šæ¶ï¼‰ï¼Œä½¿å•†å“å¯ä¾›è³¼è²·
 * @summary ä¸Šæ¶å•†å“
 */
export const publishProduct = (
    productID: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.put(
      `/api/products/upload/${productID}`,undefined,options
    );
  }



export const getPublishProductMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof publishProduct>>, TError,{productID: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof publishProduct>>, TError,{productID: string}, TContext> => {

const mutationKey = ['publishProduct'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof publishProduct>>, {productID: string}> = (props) => {
          const {productID} = props ?? {};

          return  publishProduct(productID,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PublishProductMutationResult = NonNullable<Awaited<ReturnType<typeof publishProduct>>>
    
    export type PublishProductMutationError = AxiosError<unknown>

    /**
 * @summary ä¸Šæ¶å•†å“
 */
export const usePublishProduct = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof publishProduct>>, TError,{productID: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof publishProduct>>,
        TError,
        {productID: string},
        TContext
      > => {

      const mutationOptions = getPublishProductMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * æ›´æ–°å•†å“çš„åŸºæœ¬è³‡è¨Šï¼ˆåç¨±ã€åƒ¹æ ¼ã€æè¿°ç­‰ï¼‰
 * @summary ä¿®æ”¹å•†å“è³‡è¨Š
 */
export const editProduct = (
    productID: string,
    product: Product, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.put(
      `/api/products/edit/${productID}`,
      product,options
    );
  }



export const getEditProductMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof editProduct>>, TError,{productID: string;data: Product}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof editProduct>>, TError,{productID: string;data: Product}, TContext> => {

const mutationKey = ['editProduct'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof editProduct>>, {productID: string;data: Product}> = (props) => {
          const {productID,data} = props ?? {};

          return  editProduct(productID,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EditProductMutationResult = NonNullable<Awaited<ReturnType<typeof editProduct>>>
    export type EditProductMutationBody = Product
    export type EditProductMutationError = AxiosError<unknown>

    /**
 * @summary ä¿®æ”¹å•†å“è³‡è¨Š
 */
export const useEditProduct = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof editProduct>>, TError,{productID: string;data: Product}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof editProduct>>,
        TError,
        {productID: string;data: Product},
        TContext
      > => {

      const mutationOptions = getEditProductMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary ä¾ç…§è¨‚å–®IDçµå¸³ï¼Œä¸¦å¯å¥—ç”¨å„ªæƒ åˆ¸
 */
export const payOrder = (
    orderID: string,
    params?: PayOrderParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.put(
      `/api/orders/pay/${orderID}`,undefined,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getPayOrderMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof payOrder>>, TError,{orderID: string;params?: PayOrderParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof payOrder>>, TError,{orderID: string;params?: PayOrderParams}, TContext> => {

const mutationKey = ['payOrder'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof payOrder>>, {orderID: string;params?: PayOrderParams}> = (props) => {
          const {orderID,params} = props ?? {};

          return  payOrder(orderID,params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PayOrderMutationResult = NonNullable<Awaited<ReturnType<typeof payOrder>>>
    
    export type PayOrderMutationError = AxiosError<unknown>

    /**
 * @summary ä¾ç…§è¨‚å–®IDçµå¸³ï¼Œä¸¦å¯å¥—ç”¨å„ªæƒ åˆ¸
 */
export const usePayOrder = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof payOrder>>, TError,{orderID: string;params?: PayOrderParams}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof payOrder>>,
        TError,
        {orderID: string;params?: PayOrderParams},
        TContext
      > => {

      const mutationOptions = getPayOrderMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * æ›´æ–°è³¼ç‰©è»Šä¸­æŒ‡å®šé …ç›®çš„æ•¸é‡ï¼Œæ•¸é‡ç‚º 0 æ™‚å°‡ç§»é™¤è©²é …ç›®
 * @summary æ›´æ–°è³¼ç‰©è»Šå•†å“æ•¸é‡
 */
export const updateQuantity = (
    itemId: string,
    updateCartQuantityRequest: UpdateCartQuantityRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    
    return axios.default.put(
      `/api/cart/items/${itemId}`,
      updateCartQuantityRequest,{
    ...options,}
    );
  }



export const getUpdateQuantityMutationOptions = <TError = AxiosError<string>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateQuantity>>, TError,{itemId: string;data: UpdateCartQuantityRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateQuantity>>, TError,{itemId: string;data: UpdateCartQuantityRequest}, TContext> => {

const mutationKey = ['updateQuantity'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateQuantity>>, {itemId: string;data: UpdateCartQuantityRequest}> = (props) => {
          const {itemId,data} = props ?? {};

          return  updateQuantity(itemId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateQuantityMutationResult = NonNullable<Awaited<ReturnType<typeof updateQuantity>>>
    export type UpdateQuantityMutationBody = UpdateCartQuantityRequest
    export type UpdateQuantityMutationError = AxiosError<string>

    /**
 * @summary æ›´æ–°è³¼ç‰©è»Šå•†å“æ•¸é‡
 */
export const useUpdateQuantity = <TError = AxiosError<string>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateQuantity>>, TError,{itemId: string;data: UpdateCartQuantityRequest}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateQuantity>>,
        TError,
        {itemId: string;data: UpdateCartQuantityRequest},
        TContext
      > => {

      const mutationOptions = getUpdateQuantityMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * å¾è³¼ç‰©è»Šä¸­ç§»é™¤æŒ‡å®šçš„é …ç›®
 * @summary å¾è³¼ç‰©è»Šç§»é™¤å•†å“
 */
export const removeFromCart = (
    itemId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    
    return axios.default.delete(
      `/api/cart/items/${itemId}`,{
    ...options,}
    );
  }



export const getRemoveFromCartMutationOptions = <TError = AxiosError<string>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeFromCart>>, TError,{itemId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof removeFromCart>>, TError,{itemId: string}, TContext> => {

const mutationKey = ['removeFromCart'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeFromCart>>, {itemId: string}> = (props) => {
          const {itemId} = props ?? {};

          return  removeFromCart(itemId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveFromCartMutationResult = NonNullable<Awaited<ReturnType<typeof removeFromCart>>>
    
    export type RemoveFromCartMutationError = AxiosError<string>

    /**
 * @summary å¾è³¼ç‰©è»Šç§»é™¤å•†å“
 */
export const useRemoveFromCart = <TError = AxiosError<string>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeFromCart>>, TError,{itemId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof removeFromCart>>,
        TError,
        {itemId: string},
        TContext
      > => {

      const mutationOptions = getRemoveFromCartMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary å¼·åˆ¶å°‡å„ªæƒ åˆ¸è¨­ç‚ºå·²ä½¿ç”¨
 */
export const markCouponUsed = (
    params: MarkCouponUsedParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MarkCouponUsed200>> => {
    
    
    return axios.default.post(
      `/api/userCoupon/markUsed`,undefined,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getMarkCouponUsedMutationOptions = <TError = AxiosError<MarkCouponUsed400 | MarkCouponUsed403>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof markCouponUsed>>, TError,{params: MarkCouponUsedParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof markCouponUsed>>, TError,{params: MarkCouponUsedParams}, TContext> => {

const mutationKey = ['markCouponUsed'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof markCouponUsed>>, {params: MarkCouponUsedParams}> = (props) => {
          const {params} = props ?? {};

          return  markCouponUsed(params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type MarkCouponUsedMutationResult = NonNullable<Awaited<ReturnType<typeof markCouponUsed>>>
    
    export type MarkCouponUsedMutationError = AxiosError<MarkCouponUsed400 | MarkCouponUsed403>

    /**
 * @summary å¼·åˆ¶å°‡å„ªæƒ åˆ¸è¨­ç‚ºå·²ä½¿ç”¨
 */
export const useMarkCouponUsed = <TError = AxiosError<MarkCouponUsed400 | MarkCouponUsed403>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof markCouponUsed>>, TError,{params: MarkCouponUsedParams}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof markCouponUsed>>,
        TError,
        {params: MarkCouponUsedParams},
        TContext
      > => {

      const mutationOptions = getMarkCouponUsedMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ä¾ç…§ couponID ç¯„æœ¬ç™¼æ”¾çµ¦ä½¿ç”¨è€…
 * @summary ç™¼æ”¾å„ªæƒ åˆ¸çµ¦ä½¿ç”¨è€…
 */
export const issueCouponToUser = (
    params: IssueCouponToUserParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserCoupon>> => {
    
    
    return axios.default.post(
      `/api/userCoupon/issue`,undefined,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getIssueCouponToUserMutationOptions = <TError = AxiosError<IssueCouponToUser400 | IssueCouponToUser403>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof issueCouponToUser>>, TError,{params: IssueCouponToUserParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof issueCouponToUser>>, TError,{params: IssueCouponToUserParams}, TContext> => {

const mutationKey = ['issueCouponToUser'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof issueCouponToUser>>, {params: IssueCouponToUserParams}> = (props) => {
          const {params} = props ?? {};

          return  issueCouponToUser(params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type IssueCouponToUserMutationResult = NonNullable<Awaited<ReturnType<typeof issueCouponToUser>>>
    
    export type IssueCouponToUserMutationError = AxiosError<IssueCouponToUser400 | IssueCouponToUser403>

    /**
 * @summary ç™¼æ”¾å„ªæƒ åˆ¸çµ¦ä½¿ç”¨è€…
 */
export const useIssueCouponToUser = <TError = AxiosError<IssueCouponToUser400 | IssueCouponToUser403>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof issueCouponToUser>>, TError,{params: IssueCouponToUserParams}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof issueCouponToUser>>,
        TError,
        {params: IssueCouponToUserParams},
        TContext
      > => {

      const mutationOptions = getIssueCouponToUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ç³»çµ±éš¨æ©Ÿå¾å¯ç”¨å„ªæƒ åˆ¸ä¸­æŠ½å–ä¸€å¼µï¼Œç™¼æ”¾çµ¦æŒ‡å®šä½¿ç”¨è€…
 * @summary æŠ½å–éš¨æ©Ÿå„ªæƒ åˆ¸çµ¦ä½¿ç”¨è€…
 */
export const drawCouponForUser = (
    params: DrawCouponForUserParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserCoupon>> => {
    
    
    return axios.default.post(
      `/api/userCoupon/draw`,undefined,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getDrawCouponForUserMutationOptions = <TError = AxiosError<DrawCouponForUser400 | DrawCouponForUser403>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof drawCouponForUser>>, TError,{params: DrawCouponForUserParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof drawCouponForUser>>, TError,{params: DrawCouponForUserParams}, TContext> => {

const mutationKey = ['drawCouponForUser'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof drawCouponForUser>>, {params: DrawCouponForUserParams}> = (props) => {
          const {params} = props ?? {};

          return  drawCouponForUser(params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DrawCouponForUserMutationResult = NonNullable<Awaited<ReturnType<typeof drawCouponForUser>>>
    
    export type DrawCouponForUserMutationError = AxiosError<DrawCouponForUser400 | DrawCouponForUser403>

    /**
 * @summary æŠ½å–éš¨æ©Ÿå„ªæƒ åˆ¸çµ¦ä½¿ç”¨è€…
 */
export const useDrawCouponForUser = <TError = AxiosError<DrawCouponForUser400 | DrawCouponForUser403>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof drawCouponForUser>>, TError,{params: DrawCouponForUserParams}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof drawCouponForUser>>,
        TError,
        {params: DrawCouponForUserParams},
        TContext
      > => {

      const mutationOptions = getDrawCouponForUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary çµå¸³æ™‚æ›´æ–°å„ªæƒ åˆ¸ä½¿ç”¨æ¬¡æ•¸ï¼Œé€™å€‹ä¸ç”¨ç‰¹åœ°å«ï¼Œå·²ç¶“å¯«åœ¨payorderå…§äº†
 */
export const applyCoupon = (
    params: ApplyCouponParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserCoupon>> => {
    
    
    return axios.default.post(
      `/api/userCoupon/apply`,undefined,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getApplyCouponMutationOptions = <TError = AxiosError<ApplyCoupon400 | ApplyCoupon403>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof applyCoupon>>, TError,{params: ApplyCouponParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof applyCoupon>>, TError,{params: ApplyCouponParams}, TContext> => {

const mutationKey = ['applyCoupon'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof applyCoupon>>, {params: ApplyCouponParams}> = (props) => {
          const {params} = props ?? {};

          return  applyCoupon(params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ApplyCouponMutationResult = NonNullable<Awaited<ReturnType<typeof applyCoupon>>>
    
    export type ApplyCouponMutationError = AxiosError<ApplyCoupon400 | ApplyCoupon403>

    /**
 * @summary çµå¸³æ™‚æ›´æ–°å„ªæƒ åˆ¸ä½¿ç”¨æ¬¡æ•¸ï¼Œé€™å€‹ä¸ç”¨ç‰¹åœ°å«ï¼Œå·²ç¶“å¯«åœ¨payorderå…§äº†
 */
export const useApplyCoupon = <TError = AxiosError<ApplyCoupon400 | ApplyCoupon403>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof applyCoupon>>, TError,{params: ApplyCouponParams}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof applyCoupon>>,
        TError,
        {params: ApplyCouponParams},
        TContext
      > => {

      const mutationOptions = getApplyCouponMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * é€é multipart/form-data ä¸Šå‚³åœ–ç‰‡æª”ï¼Œæª”æ¡ˆæœƒå„²å­˜åˆ° GitHub ä¸¦å›å‚³ CDN URL
 * @summary ä¸Šå‚³åœ–ç‰‡
 */
export const uploadImage = (
    uploadImageBody: UploadImageBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    const formData = new FormData();
formData.append(`file`, uploadImageBody.file)

    return axios.default.post(
      `/api/upload/image`,
      formData,{
    ...options,}
    );
  }



export const getUploadImageMutationOptions = <TError = AxiosError<string>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadImage>>, TError,{data: UploadImageBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof uploadImage>>, TError,{data: UploadImageBody}, TContext> => {

const mutationKey = ['uploadImage'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof uploadImage>>, {data: UploadImageBody}> = (props) => {
          const {data} = props ?? {};

          return  uploadImage(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UploadImageMutationResult = NonNullable<Awaited<ReturnType<typeof uploadImage>>>
    export type UploadImageMutationBody = UploadImageBody
    export type UploadImageMutationError = AxiosError<string>

    /**
 * @summary ä¸Šå‚³åœ–ç‰‡
 */
export const useUploadImage = <TError = AxiosError<string>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadImage>>, TError,{data: UploadImageBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof uploadImage>>,
        TError,
        {data: UploadImageBody},
        TContext
      > => {

      const mutationOptions = getUploadImageMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * å»ºç«‹æ–°çš„å•†å“è©•è«–ï¼Œéœ€ç¢ºèªä½¿ç”¨è€…å·²è³¼è²·è©²å•†å“ä¸”æœªè©•è«–é
 * @summary æ–°å¢è©•è«–
 */
export const createReview = (
    review: Review, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Review>> => {
    
    
    return axios.default.post(
      `/api/reviews/add`,
      review,options
    );
  }



export const getCreateReviewMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createReview>>, TError,{data: Review}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createReview>>, TError,{data: Review}, TContext> => {

const mutationKey = ['createReview'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createReview>>, {data: Review}> = (props) => {
          const {data} = props ?? {};

          return  createReview(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateReviewMutationResult = NonNullable<Awaited<ReturnType<typeof createReview>>>
    export type CreateReviewMutationBody = Review
    export type CreateReviewMutationError = AxiosError<unknown>

    /**
 * @summary æ–°å¢è©•è«–
 */
export const useCreateReview = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createReview>>, TError,{data: Review}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createReview>>,
        TError,
        {data: Review},
        TContext
      > => {

      const mutationOptions = getCreateReviewMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * å»ºç«‹æ–°å•†å“ï¼Œå•†å“é è¨­ç‹€æ…‹ç‚º PENDINGï¼ˆå¾…ä¸Šæ¶ï¼‰
 * @summary æ–°å¢å•†å“
 */
export const createProduct = (
    product: Product, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.post(
      `/api/products/add`,
      product,options
    );
  }



export const getCreateProductMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createProduct>>, TError,{data: Product}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createProduct>>, TError,{data: Product}, TContext> => {

const mutationKey = ['createProduct'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createProduct>>, {data: Product}> = (props) => {
          const {data} = props ?? {};

          return  createProduct(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateProductMutationResult = NonNullable<Awaited<ReturnType<typeof createProduct>>>
    export type CreateProductMutationBody = Product
    export type CreateProductMutationError = AxiosError<unknown>

    /**
 * @summary æ–°å¢å•†å“
 */
export const useCreateProduct = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createProduct>>, TError,{data: Product}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createProduct>>,
        TError,
        {data: Product},
        TContext
      > => {

      const mutationOptions = getCreateProductMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary å»ºç«‹è¨‚å–®
 */
export const createOrder = (
    order: Order, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.post(
      `/api/orders/add`,
      order,options
    );
  }



export const getCreateOrderMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createOrder>>, TError,{data: Order}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createOrder>>, TError,{data: Order}, TContext> => {

const mutationKey = ['createOrder'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createOrder>>, {data: Order}> = (props) => {
          const {data} = props ?? {};

          return  createOrder(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateOrderMutationResult = NonNullable<Awaited<ReturnType<typeof createOrder>>>
    export type CreateOrderMutationBody = Order
    export type CreateOrderMutationError = AxiosError<unknown>

    /**
 * @summary å»ºç«‹è¨‚å–®
 */
export const useCreateOrder = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createOrder>>, TError,{data: Order}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createOrder>>,
        TError,
        {data: Order},
        TContext
      > => {

      const mutationOptions = getCreateOrderMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * å‰µå»ºæ–°çš„è©•è«–æ­·å²è¨˜éŒ„ï¼ˆuserID å¾ JWT token ä¸­è‡ªå‹•å–å¾—ï¼‰
 * @summary æ–°å¢è©•è«–æ­·å²è¨˜éŒ„
 */
export const createReviewHistory = (
    createReviewHistoryRequest: CreateReviewHistoryRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CreateReviewHistory200>> => {
    
    
    return axios.default.post(
      `/api/history/review`,
      createReviewHistoryRequest,options
    );
  }



export const getCreateReviewHistoryMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createReviewHistory>>, TError,{data: CreateReviewHistoryRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createReviewHistory>>, TError,{data: CreateReviewHistoryRequest}, TContext> => {

const mutationKey = ['createReviewHistory'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createReviewHistory>>, {data: CreateReviewHistoryRequest}> = (props) => {
          const {data} = props ?? {};

          return  createReviewHistory(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateReviewHistoryMutationResult = NonNullable<Awaited<ReturnType<typeof createReviewHistory>>>
    export type CreateReviewHistoryMutationBody = CreateReviewHistoryRequest
    export type CreateReviewHistoryMutationError = AxiosError<unknown>

    /**
 * @summary æ–°å¢è©•è«–æ­·å²è¨˜éŒ„
 */
export const useCreateReviewHistory = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createReviewHistory>>, TError,{data: CreateReviewHistoryRequest}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createReviewHistory>>,
        TError,
        {data: CreateReviewHistoryRequest},
        TContext
      > => {

      const mutationOptions = getCreateReviewHistoryMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * å‰µå»ºæ–°çš„è³¼è²·æ­·å²è¨˜éŒ„ï¼ˆuserID å¾ JWT token ä¸­è‡ªå‹•å–å¾—ï¼ŒhistoryItems ç”±ç³»çµ±è‡ªå‹•è¨­å®šï¼‰
 * @summary æ–°å¢è³¼è²·æ­·å²è¨˜éŒ„
 */
export const createPurchaseHistory = (
    createPurchaseHistoryRequest: CreatePurchaseHistoryRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CreatePurchaseHistory200>> => {
    
    
    return axios.default.post(
      `/api/history/purchase`,
      createPurchaseHistoryRequest,options
    );
  }



export const getCreatePurchaseHistoryMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPurchaseHistory>>, TError,{data: CreatePurchaseHistoryRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createPurchaseHistory>>, TError,{data: CreatePurchaseHistoryRequest}, TContext> => {

const mutationKey = ['createPurchaseHistory'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createPurchaseHistory>>, {data: CreatePurchaseHistoryRequest}> = (props) => {
          const {data} = props ?? {};

          return  createPurchaseHistory(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreatePurchaseHistoryMutationResult = NonNullable<Awaited<ReturnType<typeof createPurchaseHistory>>>
    export type CreatePurchaseHistoryMutationBody = CreatePurchaseHistoryRequest
    export type CreatePurchaseHistoryMutationError = AxiosError<unknown>

    /**
 * @summary æ–°å¢è³¼è²·æ­·å²è¨˜éŒ„
 */
export const useCreatePurchaseHistory = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPurchaseHistory>>, TError,{data: CreatePurchaseHistoryRequest}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createPurchaseHistory>>,
        TError,
        {data: CreatePurchaseHistoryRequest},
        TContext
      > => {

      const mutationOptions = getCreatePurchaseHistoryMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * å‰µå»ºæ–°çš„ç€è¦½æ­·å²è¨˜éŒ„ï¼ˆuserID å¾ JWT token ä¸­è‡ªå‹•å–å¾—ï¼ŒhistoryItem ç”±ç³»çµ±è‡ªå‹•è¨­å®šï¼‰
 * @summary æ–°å¢ç€è¦½æ­·å²è¨˜éŒ„
 */
export const createBrowseHistory = (
    createBrowseHistoryRequest: CreateBrowseHistoryRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CreateBrowseHistory200>> => {
    
    
    return axios.default.post(
      `/api/history/browse`,
      createBrowseHistoryRequest,options
    );
  }



export const getCreateBrowseHistoryMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBrowseHistory>>, TError,{data: CreateBrowseHistoryRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createBrowseHistory>>, TError,{data: CreateBrowseHistoryRequest}, TContext> => {

const mutationKey = ['createBrowseHistory'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createBrowseHistory>>, {data: CreateBrowseHistoryRequest}> = (props) => {
          const {data} = props ?? {};

          return  createBrowseHistory(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateBrowseHistoryMutationResult = NonNullable<Awaited<ReturnType<typeof createBrowseHistory>>>
    export type CreateBrowseHistoryMutationBody = CreateBrowseHistoryRequest
    export type CreateBrowseHistoryMutationError = AxiosError<unknown>

    /**
 * @summary æ–°å¢ç€è¦½æ­·å²è¨˜éŒ„
 */
export const useCreateBrowseHistory = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBrowseHistory>>, TError,{data: CreateBrowseHistoryRequest}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createBrowseHistory>>,
        TError,
        {data: CreateBrowseHistoryRequest},
        TContext
      > => {

      const mutationOptions = getCreateBrowseHistoryMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * å‰µå»ºæ–°çš„ç«¶æ¨™æ­·å²è¨˜éŒ„ï¼ˆuserID å¾ JWT token ä¸­è‡ªå‹•å–å¾—ï¼ŒhistoryItem ç”±ç³»çµ±è‡ªå‹•è¨­å®šï¼‰
 * @summary æ–°å¢ç«¶æ¨™æ­·å²è¨˜éŒ„
 */
export const createBidHistory = (
    createBidHistoryRequest: CreateBidHistoryRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CreateBidHistory200>> => {
    
    
    return axios.default.post(
      `/api/history/bid`,
      createBidHistoryRequest,options
    );
  }



export const getCreateBidHistoryMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBidHistory>>, TError,{data: CreateBidHistoryRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createBidHistory>>, TError,{data: CreateBidHistoryRequest}, TContext> => {

const mutationKey = ['createBidHistory'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createBidHistory>>, {data: CreateBidHistoryRequest}> = (props) => {
          const {data} = props ?? {};

          return  createBidHistory(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateBidHistoryMutationResult = NonNullable<Awaited<ReturnType<typeof createBidHistory>>>
    export type CreateBidHistoryMutationBody = CreateBidHistoryRequest
    export type CreateBidHistoryMutationError = AxiosError<unknown>

    /**
 * @summary æ–°å¢ç«¶æ¨™æ­·å²è¨˜éŒ„
 */
export const useCreateBidHistory = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBidHistory>>, TError,{data: CreateBidHistoryRequest}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createBidHistory>>,
        TError,
        {data: CreateBidHistoryRequest},
        TContext
      > => {

      const mutationOptions = getCreateBidHistoryMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * å°‡æŒ‡å®šå•†å“åŠ å…¥ä½¿ç”¨è€…çš„æ”¶è—æ¸…å–®ï¼ˆç„¡æ”¶è—ä¸Šé™ï¼‰ï¼Œæœƒè‡ªå‹•è¨˜éŒ„åŠ å…¥æ™‚é–“
 * @summary ã€CREATEã€‘åŠ å…¥æ”¶è—æ¸…å–®
 */
export const addToFavorites = (
    userId: string,
    productId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.post(
      `/api/favorites/${userId}/items/${productId}`,undefined,options
    );
  }



export const getAddToFavoritesMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addToFavorites>>, TError,{userId: string;productId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addToFavorites>>, TError,{userId: string;productId: string}, TContext> => {

const mutationKey = ['addToFavorites'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addToFavorites>>, {userId: string;productId: string}> = (props) => {
          const {userId,productId} = props ?? {};

          return  addToFavorites(userId,productId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddToFavoritesMutationResult = NonNullable<Awaited<ReturnType<typeof addToFavorites>>>
    
    export type AddToFavoritesMutationError = AxiosError<unknown>

    /**
 * @summary ã€CREATEã€‘åŠ å…¥æ”¶è—æ¸…å–®
 */
export const useAddToFavorites = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addToFavorites>>, TError,{userId: string;productId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addToFavorites>>,
        TError,
        {userId: string;productId: string},
        TContext
      > => {

      const mutationOptions = getAddToFavoritesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * å¾æ”¶è—æ¸…å–®ä¸­ç§»é™¤æŒ‡å®šå•†å“
 * @summary ã€DELETEã€‘ç§»é™¤æ”¶è—
 */
export const removeFromFavorites = (
    userId: string,
    productId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.delete(
      `/api/favorites/${userId}/items/${productId}`,options
    );
  }



export const getRemoveFromFavoritesMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeFromFavorites>>, TError,{userId: string;productId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof removeFromFavorites>>, TError,{userId: string;productId: string}, TContext> => {

const mutationKey = ['removeFromFavorites'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeFromFavorites>>, {userId: string;productId: string}> = (props) => {
          const {userId,productId} = props ?? {};

          return  removeFromFavorites(userId,productId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveFromFavoritesMutationResult = NonNullable<Awaited<ReturnType<typeof removeFromFavorites>>>
    
    export type RemoveFromFavoritesMutationError = AxiosError<unknown>

    /**
 * @summary ã€DELETEã€‘ç§»é™¤æ”¶è—
 */
export const useRemoveFromFavorites = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeFromFavorites>>, TError,{userId: string;productId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof removeFromFavorites>>,
        TError,
        {userId: string;productId: string},
        TContext
      > => {

      const mutationOptions = getRemoveFromFavoritesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * å°‡å•†å“è¨­å®šç‚ºæ‹è³£æ¨¡å¼ï¼Œéœ€æŒ‡å®šèµ·æ¨™åƒ¹å’ŒçµæŸæ™‚é–“ã€‚æ™‚é–“æ ¼å¼ç‚º ISO 8601 (yyyy-MM-ddTHH:mm:ss)
 * @summary å»ºç«‹æ‹è³£å•†å“
 */
export const createAuction = (
    productID: string,
    params: CreateAuctionParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.post(
      `/api/createAucs/${productID}`,undefined,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getCreateAuctionMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAuction>>, TError,{productID: string;params: CreateAuctionParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createAuction>>, TError,{productID: string;params: CreateAuctionParams}, TContext> => {

const mutationKey = ['createAuction'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAuction>>, {productID: string;params: CreateAuctionParams}> = (props) => {
          const {productID,params} = props ?? {};

          return  createAuction(productID,params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAuctionMutationResult = NonNullable<Awaited<ReturnType<typeof createAuction>>>
    
    export type CreateAuctionMutationError = AxiosError<unknown>

    /**
 * @summary å»ºç«‹æ‹è³£å•†å“
 */
export const useCreateAuction = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAuction>>, TError,{productID: string;params: CreateAuctionParams}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createAuction>>,
        TError,
        {productID: string;params: CreateAuctionParams},
        TContext
      > => {

      const mutationOptions = getCreateAuctionMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * å›å‚³ç³»çµ±å…§æ‰€æœ‰å¯ä½¿ç”¨çš„å„ªæƒ åˆ¸é¡å‹
 * @summary å–å¾—æ‰€æœ‰å„ªæƒ åˆ¸
 */
export const getAllCoupons = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Coupon>> => {
    
    
    return axios.default.get(
      `/api/coupons`,options
    );
  }




export const getGetAllCouponsQueryKey = () => {
    return [
    `/api/coupons`
    ] as const;
    }

    
export const getGetAllCouponsQueryOptions = <TData = Awaited<ReturnType<typeof getAllCoupons>>, TError = AxiosError<GetAllCoupons404 | GetAllCoupons500>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllCoupons>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllCouponsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllCoupons>>> = ({ signal }) => getAllCoupons({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllCoupons>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllCouponsQueryResult = NonNullable<Awaited<ReturnType<typeof getAllCoupons>>>
export type GetAllCouponsQueryError = AxiosError<GetAllCoupons404 | GetAllCoupons500>


export function useGetAllCoupons<TData = Awaited<ReturnType<typeof getAllCoupons>>, TError = AxiosError<GetAllCoupons404 | GetAllCoupons500>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllCoupons>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllCoupons>>,
          TError,
          Awaited<ReturnType<typeof getAllCoupons>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllCoupons<TData = Awaited<ReturnType<typeof getAllCoupons>>, TError = AxiosError<GetAllCoupons404 | GetAllCoupons500>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllCoupons>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllCoupons>>,
          TError,
          Awaited<ReturnType<typeof getAllCoupons>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllCoupons<TData = Awaited<ReturnType<typeof getAllCoupons>>, TError = AxiosError<GetAllCoupons404 | GetAllCoupons500>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllCoupons>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary å–å¾—æ‰€æœ‰å„ªæƒ åˆ¸
 */

export function useGetAllCoupons<TData = Awaited<ReturnType<typeof getAllCoupons>>, TError = AxiosError<GetAllCoupons404 | GetAllCoupons500>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllCoupons>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllCouponsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary å»ºç«‹æ–°çš„å„ªæƒ åˆ¸
 */
export const createCoupon = (
    product: Product, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Coupon>> => {
    
    
    return axios.default.post(
      `/api/coupons`,
      product,options
    );
  }



export const getCreateCouponMutationOptions = <TError = AxiosError<CreateCoupon400 | CreateCoupon500>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCoupon>>, TError,{data: Product}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createCoupon>>, TError,{data: Product}, TContext> => {

const mutationKey = ['createCoupon'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCoupon>>, {data: Product}> = (props) => {
          const {data} = props ?? {};

          return  createCoupon(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCouponMutationResult = NonNullable<Awaited<ReturnType<typeof createCoupon>>>
    export type CreateCouponMutationBody = Product
    export type CreateCouponMutationError = AxiosError<CreateCoupon400 | CreateCoupon500>

    /**
 * @summary å»ºç«‹æ–°çš„å„ªæƒ åˆ¸
 */
export const useCreateCoupon = <TError = AxiosError<CreateCoupon400 | CreateCoupon500>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCoupon>>, TError,{data: Product}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createCoupon>>,
        TError,
        {data: Product},
        TContext
      > => {

      const mutationOptions = getCreateCouponMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * å°‡æŒ‡å®šå•†å“ä»¥æŒ‡å®šæ•¸é‡åŠ å…¥è³¼ç‰©è»Šï¼Œè‹¥å·²å­˜åœ¨å‰‡ç´¯åŠ æ•¸é‡
 * @summary åŠ å…¥å•†å“åˆ°è³¼ç‰©è»Š
 */
export const addToCart = (
    addToCartRequest: AddToCartRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    
    return axios.default.post(
      `/api/cart/items`,
      addToCartRequest,{
    ...options,}
    );
  }



export const getAddToCartMutationOptions = <TError = AxiosError<string>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addToCart>>, TError,{data: AddToCartRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addToCart>>, TError,{data: AddToCartRequest}, TContext> => {

const mutationKey = ['addToCart'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addToCart>>, {data: AddToCartRequest}> = (props) => {
          const {data} = props ?? {};

          return  addToCart(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddToCartMutationResult = NonNullable<Awaited<ReturnType<typeof addToCart>>>
    export type AddToCartMutationBody = AddToCartRequest
    export type AddToCartMutationError = AxiosError<string>

    /**
 * @summary åŠ å…¥å•†å“åˆ°è³¼ç‰©è»Š
 */
export const useAddToCart = <TError = AxiosError<string>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addToCart>>, TError,{data: AddToCartRequest}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addToCart>>,
        TError,
        {data: AddToCartRequest},
        TContext
      > => {

      const mutationOptions = getAddToCartMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * å°æŒ‡å®šå•†å“é€²è¡Œå‡ºåƒ¹ï¼Œå‡ºåƒ¹é‡‘é¡å¿…é ˆé«˜æ–¼ç•¶å‰æœ€é«˜å‡ºåƒ¹ï¼Œæ³¨æ„ä¸‹æ–¹ç¯„ä¾‹IDå·²ç¶“å°æ‡‰åˆ°æ¸¬è©¦ç”¨çš„å•†å“ï¼Œå¯ä»¥æ”¾å¿ƒæ¸¬è©¦
 * @summary ç«¶æ¨™å‡ºåƒ¹
 */
export const placeBid = (
    id: string,
    params: PlaceBidParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.post(
      `/api/bids/${id}`,undefined,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getPlaceBidMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof placeBid>>, TError,{id: string;params: PlaceBidParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof placeBid>>, TError,{id: string;params: PlaceBidParams}, TContext> => {

const mutationKey = ['placeBid'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof placeBid>>, {id: string;params: PlaceBidParams}> = (props) => {
          const {id,params} = props ?? {};

          return  placeBid(id,params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PlaceBidMutationResult = NonNullable<Awaited<ReturnType<typeof placeBid>>>
    
    export type PlaceBidMutationError = AxiosError<unknown>

    /**
 * @summary ç«¶æ¨™å‡ºåƒ¹
 */
export const usePlaceBid = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof placeBid>>, TError,{id: string;params: PlaceBidParams}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof placeBid>>,
        TError,
        {id: string;params: PlaceBidParams},
        TContext
      > => {

      const mutationOptions = getPlaceBidMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * æ–°ä½¿ç”¨è€…è¨»å†Šå¸³è™Ÿã€‚è¨»å†ŠæˆåŠŸå¾Œæœƒè‡ªå‹•ç™»å…¥ä¸¦è¿”å› JWT Tokenã€‚
 * @summary ä½¿ç”¨è€…è¨»å†Š
 */
export const register = (
    registerRequest: RegisterRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AuthResponse>> => {
    
    
    return axios.default.post(
      `/api/auth/register`,
      registerRequest,options
    );
  }



export const getRegisterMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof register>>, TError,{data: RegisterRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof register>>, TError,{data: RegisterRequest}, TContext> => {

const mutationKey = ['register'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof register>>, {data: RegisterRequest}> = (props) => {
          const {data} = props ?? {};

          return  register(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RegisterMutationResult = NonNullable<Awaited<ReturnType<typeof register>>>
    export type RegisterMutationBody = RegisterRequest
    export type RegisterMutationError = AxiosError<unknown>

    /**
 * @summary ä½¿ç”¨è€…è¨»å†Š
 */
export const useRegister = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof register>>, TError,{data: RegisterRequest}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof register>>,
        TError,
        {data: RegisterRequest},
        TContext
      > => {

      const mutationOptions = getRegisterMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ç™»å‡ºç³»çµ±ã€‚ç”±æ–¼ JWT æ˜¯ç„¡ç‹€æ…‹çš„ï¼Œå®¢æˆ¶ç«¯éœ€è¦åˆªé™¤å„²å­˜çš„ Tokenã€‚Token æœƒåœ¨ 30 åˆ†é˜å¾Œè‡ªå‹•éæœŸå¤±æ•ˆã€‚
 * @summary ä½¿ç”¨è€…ç™»å‡º
 */
export const logout = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.post(
      `/api/auth/logout`,undefined,options
    );
  }



export const getLogoutMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,void, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,void, TContext> => {

const mutationKey = ['logout'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof logout>>, void> = () => {
          

          return  logout(axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LogoutMutationResult = NonNullable<Awaited<ReturnType<typeof logout>>>
    
    export type LogoutMutationError = AxiosError<unknown>

    /**
 * @summary ä½¿ç”¨è€…ç™»å‡º
 */
export const useLogout = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,void, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof logout>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getLogoutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ä½¿ç”¨è€…ç™»å…¥ç³»çµ±ã€‚ç™»å…¥æˆåŠŸå¾Œè¿”å› JWT Tokenï¼Œå‰ç«¯éœ€è¦åœ¨å¾ŒçºŒè«‹æ±‚çš„ Authorization Header ä¸­æ”œå¸¶æ­¤ Tokenã€‚
 * @summary ä½¿ç”¨è€…ç™»å…¥
 */
export const login = (
    loginRequest: LoginRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AuthResponse>> => {
    
    
    return axios.default.post(
      `/api/auth/login`,
      loginRequest,options
    );
  }



export const getLoginMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginRequest}, TContext> => {

const mutationKey = ['login'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof login>>, {data: LoginRequest}> = (props) => {
          const {data} = props ?? {};

          return  login(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LoginMutationResult = NonNullable<Awaited<ReturnType<typeof login>>>
    export type LoginMutationBody = LoginRequest
    export type LoginMutationError = AxiosError<unknown>

    /**
 * @summary ä½¿ç”¨è€…ç™»å…¥
 */
export const useLogin = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginRequest}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof login>>,
        TError,
        {data: LoginRequest},
        TContext
      > => {

      const mutationOptions = getLoginMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * è¼¸å…¥ userIdï¼Œå–å¾—è©²ä½¿ç”¨è€…çš„æ‰€æœ‰å„ªæƒ åˆ¸æ¸…å–®
 * @summary å–å¾—ä½¿ç”¨è€…å…¨éƒ¨å„ªæƒ åˆ¸
 */
export const getUserAllCoupons = (
    userId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserCoupon>> => {
    
    
    return axios.default.get(
      `/api/userCoupon/${userId}`,options
    );
  }




export const getGetUserAllCouponsQueryKey = (userId?: string,) => {
    return [
    `/api/userCoupon/${userId}`
    ] as const;
    }

    
export const getGetUserAllCouponsQueryOptions = <TData = Awaited<ReturnType<typeof getUserAllCoupons>>, TError = AxiosError<GetUserAllCoupons404>>(userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserAllCoupons>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserAllCouponsQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserAllCoupons>>> = ({ signal }) => getUserAllCoupons(userId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserAllCoupons>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserAllCouponsQueryResult = NonNullable<Awaited<ReturnType<typeof getUserAllCoupons>>>
export type GetUserAllCouponsQueryError = AxiosError<GetUserAllCoupons404>


export function useGetUserAllCoupons<TData = Awaited<ReturnType<typeof getUserAllCoupons>>, TError = AxiosError<GetUserAllCoupons404>>(
 userId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserAllCoupons>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserAllCoupons>>,
          TError,
          Awaited<ReturnType<typeof getUserAllCoupons>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserAllCoupons<TData = Awaited<ReturnType<typeof getUserAllCoupons>>, TError = AxiosError<GetUserAllCoupons404>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserAllCoupons>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserAllCoupons>>,
          TError,
          Awaited<ReturnType<typeof getUserAllCoupons>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserAllCoupons<TData = Awaited<ReturnType<typeof getUserAllCoupons>>, TError = AxiosError<GetUserAllCoupons404>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserAllCoupons>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary å–å¾—ä½¿ç”¨è€…å…¨éƒ¨å„ªæƒ åˆ¸
 */

export function useGetUserAllCoupons<TData = Awaited<ReturnType<typeof getUserAllCoupons>>, TError = AxiosError<GetUserAllCoupons404>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserAllCoupons>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserAllCouponsQueryOptions(userId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * æ ¹æ“šä½¿ç”¨è€… ID å–å¾—è©²ä½¿ç”¨è€…çš„å…¬é–‹è³‡è¨Šï¼ŒåŒ…å«æ­£åœ¨è²©å”®çš„å•†å“åˆ—è¡¨ã€‚

**ç”¨é€”**ï¼š
- æŸ¥çœ‹å…¶ä»–ä½¿ç”¨è€…çš„åŸºæœ¬è³‡æ–™
- èŠå¤©åŠŸèƒ½é¡¯ç¤ºå°æ–¹è³‡è¨Š
- å•†å“é é¢é¡¯ç¤ºè³£å®¶è³‡è¨Š
- æŸ¥çœ‹è³£å®¶æ­£åœ¨è²©å”®çš„æ‰€æœ‰å•†å“

**æ³¨æ„**ï¼šæ­¤ API ä¸éœ€è¦ç™»å…¥ï¼Œä¸”ä¸æœƒè¿”å›æ•æ„Ÿè³‡è¨Šï¼ˆå¦‚ emailï¼‰

 * @summary å–å¾—ä½¿ç”¨è€…å…¬é–‹è³‡è¨Š
 */
export const getUserById = (
    userId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PublicUserInfoResponse>> => {
    
    
    return axios.default.get(
      `/api/user/${userId}`,options
    );
  }




export const getGetUserByIdQueryKey = (userId?: string,) => {
    return [
    `/api/user/${userId}`
    ] as const;
    }

    
export const getGetUserByIdQueryOptions = <TData = Awaited<ReturnType<typeof getUserById>>, TError = AxiosError<GetUserById404>>(userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserByIdQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserById>>> = ({ signal }) => getUserById(userId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getUserById>>>
export type GetUserByIdQueryError = AxiosError<GetUserById404>


export function useGetUserById<TData = Awaited<ReturnType<typeof getUserById>>, TError = AxiosError<GetUserById404>>(
 userId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserById>>,
          TError,
          Awaited<ReturnType<typeof getUserById>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserById<TData = Awaited<ReturnType<typeof getUserById>>, TError = AxiosError<GetUserById404>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserById>>,
          TError,
          Awaited<ReturnType<typeof getUserById>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserById<TData = Awaited<ReturnType<typeof getUserById>>, TError = AxiosError<GetUserById404>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary å–å¾—ä½¿ç”¨è€…å…¬é–‹è³‡è¨Š
 */

export function useGetUserById<TData = Awaited<ReturnType<typeof getUserById>>, TError = AxiosError<GetUserById404>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserByIdQueryOptions(userId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * æ ¹æ“šå•†å“åç¨±é€²è¡Œç²¾ç¢ºæœå°‹ï¼Œå•†å“åç¨±éœ€å®Œå…¨ç¬¦åˆ
 * @summary ç²¾ç¢ºæœå°‹å•†å“
 */
export const searchByKeyword = (
    params: SearchByKeywordParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Product>> => {
    
    
    return axios.default.get(
      `/api/search`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getSearchByKeywordQueryKey = (params?: SearchByKeywordParams,) => {
    return [
    `/api/search`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getSearchByKeywordQueryOptions = <TData = Awaited<ReturnType<typeof searchByKeyword>>, TError = AxiosError<unknown>>(params: SearchByKeywordParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchByKeyword>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchByKeywordQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchByKeyword>>> = ({ signal }) => searchByKeyword(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchByKeyword>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SearchByKeywordQueryResult = NonNullable<Awaited<ReturnType<typeof searchByKeyword>>>
export type SearchByKeywordQueryError = AxiosError<unknown>


export function useSearchByKeyword<TData = Awaited<ReturnType<typeof searchByKeyword>>, TError = AxiosError<unknown>>(
 params: SearchByKeywordParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchByKeyword>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchByKeyword>>,
          TError,
          Awaited<ReturnType<typeof searchByKeyword>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchByKeyword<TData = Awaited<ReturnType<typeof searchByKeyword>>, TError = AxiosError<unknown>>(
 params: SearchByKeywordParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchByKeyword>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchByKeyword>>,
          TError,
          Awaited<ReturnType<typeof searchByKeyword>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchByKeyword<TData = Awaited<ReturnType<typeof searchByKeyword>>, TError = AxiosError<unknown>>(
 params: SearchByKeywordParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchByKeyword>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ç²¾ç¢ºæœå°‹å•†å“
 */

export function useSearchByKeyword<TData = Awaited<ReturnType<typeof searchByKeyword>>, TError = AxiosError<unknown>>(
 params: SearchByKeywordParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchByKeyword>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSearchByKeywordQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * å›å‚³ç³»çµ±ä¸­æ‰€æœ‰å•†å“çš„è©•è«–ç´€éŒ„
 * @summary å–å¾—æ‰€æœ‰è©•è«–æ­·å²
 */
export const getAllReviewHistory = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Review>> => {
    
    
    return axios.default.get(
      `/api/reviews/history`,options
    );
  }




export const getGetAllReviewHistoryQueryKey = () => {
    return [
    `/api/reviews/history`
    ] as const;
    }

    
export const getGetAllReviewHistoryQueryOptions = <TData = Awaited<ReturnType<typeof getAllReviewHistory>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllReviewHistory>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllReviewHistoryQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllReviewHistory>>> = ({ signal }) => getAllReviewHistory({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllReviewHistory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllReviewHistoryQueryResult = NonNullable<Awaited<ReturnType<typeof getAllReviewHistory>>>
export type GetAllReviewHistoryQueryError = AxiosError<unknown>


export function useGetAllReviewHistory<TData = Awaited<ReturnType<typeof getAllReviewHistory>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllReviewHistory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllReviewHistory>>,
          TError,
          Awaited<ReturnType<typeof getAllReviewHistory>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllReviewHistory<TData = Awaited<ReturnType<typeof getAllReviewHistory>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllReviewHistory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllReviewHistory>>,
          TError,
          Awaited<ReturnType<typeof getAllReviewHistory>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllReviewHistory<TData = Awaited<ReturnType<typeof getAllReviewHistory>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllReviewHistory>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary å–å¾—æ‰€æœ‰è©•è«–æ­·å²
 */

export function useGetAllReviewHistory<TData = Awaited<ReturnType<typeof getAllReviewHistory>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllReviewHistory>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllReviewHistoryQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * å›å‚³æŒ‡å®šä½¿ç”¨è€…çš„æ‰€æœ‰è©•è«–
 * @summary ä¾ä½¿ç”¨è€…IDå–å¾—è©•è«–
 */
export const getReviewsByUserId = (
    userID: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Review>> => {
    
    
    return axios.default.get(
      `/api/reviews/byUser/${userID}`,options
    );
  }




export const getGetReviewsByUserIdQueryKey = (userID?: string,) => {
    return [
    `/api/reviews/byUser/${userID}`
    ] as const;
    }

    
export const getGetReviewsByUserIdQueryOptions = <TData = Awaited<ReturnType<typeof getReviewsByUserId>>, TError = AxiosError<unknown>>(userID: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewsByUserId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetReviewsByUserIdQueryKey(userID);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getReviewsByUserId>>> = ({ signal }) => getReviewsByUserId(userID, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userID), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getReviewsByUserId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetReviewsByUserIdQueryResult = NonNullable<Awaited<ReturnType<typeof getReviewsByUserId>>>
export type GetReviewsByUserIdQueryError = AxiosError<unknown>


export function useGetReviewsByUserId<TData = Awaited<ReturnType<typeof getReviewsByUserId>>, TError = AxiosError<unknown>>(
 userID: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewsByUserId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReviewsByUserId>>,
          TError,
          Awaited<ReturnType<typeof getReviewsByUserId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetReviewsByUserId<TData = Awaited<ReturnType<typeof getReviewsByUserId>>, TError = AxiosError<unknown>>(
 userID: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewsByUserId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReviewsByUserId>>,
          TError,
          Awaited<ReturnType<typeof getReviewsByUserId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetReviewsByUserId<TData = Awaited<ReturnType<typeof getReviewsByUserId>>, TError = AxiosError<unknown>>(
 userID: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewsByUserId>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ä¾ä½¿ç”¨è€…IDå–å¾—è©•è«–
 */

export function useGetReviewsByUserId<TData = Awaited<ReturnType<typeof getReviewsByUserId>>, TError = AxiosError<unknown>>(
 userID: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewsByUserId>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetReviewsByUserIdQueryOptions(userID,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * å›å‚³æŒ‡å®šå•†å“çš„æ‰€æœ‰è©•è«–
 * @summary ä¾å•†å“IDå–å¾—è©•è«–
 */
export const getReviewsByProductId = (
    productID: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Review>> => {
    
    
    return axios.default.get(
      `/api/reviews/byProduct/${productID}`,options
    );
  }




export const getGetReviewsByProductIdQueryKey = (productID?: string,) => {
    return [
    `/api/reviews/byProduct/${productID}`
    ] as const;
    }

    
export const getGetReviewsByProductIdQueryOptions = <TData = Awaited<ReturnType<typeof getReviewsByProductId>>, TError = AxiosError<unknown>>(productID: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewsByProductId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetReviewsByProductIdQueryKey(productID);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getReviewsByProductId>>> = ({ signal }) => getReviewsByProductId(productID, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(productID), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getReviewsByProductId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetReviewsByProductIdQueryResult = NonNullable<Awaited<ReturnType<typeof getReviewsByProductId>>>
export type GetReviewsByProductIdQueryError = AxiosError<unknown>


export function useGetReviewsByProductId<TData = Awaited<ReturnType<typeof getReviewsByProductId>>, TError = AxiosError<unknown>>(
 productID: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewsByProductId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReviewsByProductId>>,
          TError,
          Awaited<ReturnType<typeof getReviewsByProductId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetReviewsByProductId<TData = Awaited<ReturnType<typeof getReviewsByProductId>>, TError = AxiosError<unknown>>(
 productID: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewsByProductId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReviewsByProductId>>,
          TError,
          Awaited<ReturnType<typeof getReviewsByProductId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetReviewsByProductId<TData = Awaited<ReturnType<typeof getReviewsByProductId>>, TError = AxiosError<unknown>>(
 productID: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewsByProductId>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ä¾å•†å“IDå–å¾—è©•è«–
 */

export function useGetReviewsByProductId<TData = Awaited<ReturnType<typeof getReviewsByProductId>>, TError = AxiosError<unknown>>(
 productID: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewsByProductId>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetReviewsByProductIdQueryOptions(productID,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * åˆ†é æŸ¥è©¢æ‰€æœ‰å•†å“ï¼Œæ”¯æ´è‡ªè¨‚æ¯é å•†å“æ•¸é‡
 * @summary å–å¾—å•†å“åˆ—è¡¨ï¼ˆåˆ†é ï¼‰
 */
export const getAllProduct = (
    params?: GetAllProductParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Product>> => {
    
    
    return axios.default.get(
      `/api/products`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getGetAllProductQueryKey = (params?: GetAllProductParams,) => {
    return [
    `/api/products`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetAllProductQueryOptions = <TData = Awaited<ReturnType<typeof getAllProduct>>, TError = AxiosError<GetAllProduct404>>(params?: GetAllProductParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllProduct>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllProductQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllProduct>>> = ({ signal }) => getAllProduct(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllProduct>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllProductQueryResult = NonNullable<Awaited<ReturnType<typeof getAllProduct>>>
export type GetAllProductQueryError = AxiosError<GetAllProduct404>


export function useGetAllProduct<TData = Awaited<ReturnType<typeof getAllProduct>>, TError = AxiosError<GetAllProduct404>>(
 params: undefined |  GetAllProductParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllProduct>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllProduct>>,
          TError,
          Awaited<ReturnType<typeof getAllProduct>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllProduct<TData = Awaited<ReturnType<typeof getAllProduct>>, TError = AxiosError<GetAllProduct404>>(
 params?: GetAllProductParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllProduct>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllProduct>>,
          TError,
          Awaited<ReturnType<typeof getAllProduct>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllProduct<TData = Awaited<ReturnType<typeof getAllProduct>>, TError = AxiosError<GetAllProduct404>>(
 params?: GetAllProductParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllProduct>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary å–å¾—å•†å“åˆ—è¡¨ï¼ˆåˆ†é ï¼‰
 */

export function useGetAllProduct<TData = Awaited<ReturnType<typeof getAllProduct>>, TError = AxiosError<GetAllProduct404>>(
 params?: GetAllProductParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllProduct>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllProductQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * æ ¹æ“šå•†å“ ID æŸ¥è©¢å•†å“è©³ç´°è³‡è¨Š
 * @summary å–å¾—å–®ä¸€å•†å“è³‡è¨Š
 */
export const getProductById = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Product>> => {
    
    
    return axios.default.get(
      `/api/products/${id}`,options
    );
  }




export const getGetProductByIdQueryKey = (id?: string,) => {
    return [
    `/api/products/${id}`
    ] as const;
    }

    
export const getGetProductByIdQueryOptions = <TData = Awaited<ReturnType<typeof getProductById>>, TError = AxiosError<unknown>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductById>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProductByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProductById>>> = ({ signal }) => getProductById(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProductById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProductByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getProductById>>>
export type GetProductByIdQueryError = AxiosError<unknown>


export function useGetProductById<TData = Awaited<ReturnType<typeof getProductById>>, TError = AxiosError<unknown>>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductById>>,
          TError,
          Awaited<ReturnType<typeof getProductById>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProductById<TData = Awaited<ReturnType<typeof getProductById>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProductById>>,
          TError,
          Awaited<ReturnType<typeof getProductById>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProductById<TData = Awaited<ReturnType<typeof getProductById>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductById>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary å–å¾—å–®ä¸€å•†å“è³‡è¨Š
 */

export function useGetProductById<TData = Awaited<ReturnType<typeof getProductById>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProductById>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetProductByIdQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary å–å¾—æ‰€æœ‰å•†å“ï¼ˆå¯æ’åºï¼‰
 */
export const getAllProductsSorted = (
    params?: GetAllProductsSortedParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetAllProductsSorted200>> => {
    
    
    return axios.default.get(
      `/api/products/sorted`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getGetAllProductsSortedQueryKey = (params?: GetAllProductsSortedParams,) => {
    return [
    `/api/products/sorted`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetAllProductsSortedQueryOptions = <TData = Awaited<ReturnType<typeof getAllProductsSorted>>, TError = AxiosError<GetAllProductsSorted404>>(params?: GetAllProductsSortedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllProductsSorted>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllProductsSortedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllProductsSorted>>> = ({ signal }) => getAllProductsSorted(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllProductsSorted>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllProductsSortedQueryResult = NonNullable<Awaited<ReturnType<typeof getAllProductsSorted>>>
export type GetAllProductsSortedQueryError = AxiosError<GetAllProductsSorted404>


export function useGetAllProductsSorted<TData = Awaited<ReturnType<typeof getAllProductsSorted>>, TError = AxiosError<GetAllProductsSorted404>>(
 params: undefined |  GetAllProductsSortedParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllProductsSorted>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllProductsSorted>>,
          TError,
          Awaited<ReturnType<typeof getAllProductsSorted>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllProductsSorted<TData = Awaited<ReturnType<typeof getAllProductsSorted>>, TError = AxiosError<GetAllProductsSorted404>>(
 params?: GetAllProductsSortedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllProductsSorted>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllProductsSorted>>,
          TError,
          Awaited<ReturnType<typeof getAllProductsSorted>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllProductsSorted<TData = Awaited<ReturnType<typeof getAllProductsSorted>>, TError = AxiosError<GetAllProductsSorted404>>(
 params?: GetAllProductsSortedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllProductsSorted>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary å–å¾—æ‰€æœ‰å•†å“ï¼ˆå¯æ’åºï¼‰
 */

export function useGetAllProductsSorted<TData = Awaited<ReturnType<typeof getAllProductsSorted>>, TError = AxiosError<GetAllProductsSorted404>>(
 params?: GetAllProductsSortedParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllProductsSorted>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllProductsSortedQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * å›å‚³ç³»çµ±å…§æ‰€æœ‰å•†å“çš„åˆ†é¡åˆ—è¡¨
 * @summary å–å¾—æ‰€æœ‰å•†å“åˆ†é¡
 */
export const getAllCategory = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    
    return axios.default.get(
      `/api/products/Category`,{
    ...options,}
    );
  }




export const getGetAllCategoryQueryKey = () => {
    return [
    `/api/products/Category`
    ] as const;
    }

    
export const getGetAllCategoryQueryOptions = <TData = Awaited<ReturnType<typeof getAllCategory>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllCategory>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllCategoryQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllCategory>>> = ({ signal }) => getAllCategory({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllCategory>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllCategoryQueryResult = NonNullable<Awaited<ReturnType<typeof getAllCategory>>>
export type GetAllCategoryQueryError = AxiosError<unknown>


export function useGetAllCategory<TData = Awaited<ReturnType<typeof getAllCategory>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllCategory>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllCategory>>,
          TError,
          Awaited<ReturnType<typeof getAllCategory>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllCategory<TData = Awaited<ReturnType<typeof getAllCategory>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllCategory>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllCategory>>,
          TError,
          Awaited<ReturnType<typeof getAllCategory>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllCategory<TData = Awaited<ReturnType<typeof getAllCategory>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllCategory>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary å–å¾—æ‰€æœ‰å•†å“åˆ†é¡
 */

export function useGetAllCategory<TData = Awaited<ReturnType<typeof getAllCategory>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllCategory>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllCategoryQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary ä¾ç…§è¨‚å–®IDæœå°‹
 */
export const getOrderById = (
    orderID: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.get(
      `/api/orders/${orderID}`,options
    );
  }




export const getGetOrderByIdQueryKey = (orderID?: string,) => {
    return [
    `/api/orders/${orderID}`
    ] as const;
    }

    
export const getGetOrderByIdQueryOptions = <TData = Awaited<ReturnType<typeof getOrderById>>, TError = AxiosError<unknown>>(orderID: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOrderByIdQueryKey(orderID);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrderById>>> = ({ signal }) => getOrderById(orderID, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(orderID), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOrderByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getOrderById>>>
export type GetOrderByIdQueryError = AxiosError<unknown>


export function useGetOrderById<TData = Awaited<ReturnType<typeof getOrderById>>, TError = AxiosError<unknown>>(
 orderID: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderById>>,
          TError,
          Awaited<ReturnType<typeof getOrderById>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderById<TData = Awaited<ReturnType<typeof getOrderById>>, TError = AxiosError<unknown>>(
 orderID: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderById>>,
          TError,
          Awaited<ReturnType<typeof getOrderById>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOrderById<TData = Awaited<ReturnType<typeof getOrderById>>, TError = AxiosError<unknown>>(
 orderID: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ä¾ç…§è¨‚å–®IDæœå°‹
 */

export function useGetOrderById<TData = Awaited<ReturnType<typeof getOrderById>>, TError = AxiosError<unknown>>(
 orderID: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOrderByIdQueryOptions(orderID,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * æ ¹æ“šæ­·å²è¨˜éŒ„ ID æŸ¥è©¢ç‰¹å®šçš„æ­·å²è¨˜éŒ„ï¼ˆæ”¯æ´æ‰€æœ‰å­é¡å‹ï¼‰
 * @summary æ ¹æ“šæ­·å²è¨˜éŒ„ ID æŸ¥è©¢
 */
export const getHistoryById = (
    historyId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<History>> => {
    
    
    return axios.default.get(
      `/api/history/${historyId}`,options
    );
  }




export const getGetHistoryByIdQueryKey = (historyId?: string,) => {
    return [
    `/api/history/${historyId}`
    ] as const;
    }

    
export const getGetHistoryByIdQueryOptions = <TData = Awaited<ReturnType<typeof getHistoryById>>, TError = AxiosError<GetHistoryById404 | GetHistoryById500>>(historyId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getHistoryById>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetHistoryByIdQueryKey(historyId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getHistoryById>>> = ({ signal }) => getHistoryById(historyId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(historyId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getHistoryById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetHistoryByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getHistoryById>>>
export type GetHistoryByIdQueryError = AxiosError<GetHistoryById404 | GetHistoryById500>


export function useGetHistoryById<TData = Awaited<ReturnType<typeof getHistoryById>>, TError = AxiosError<GetHistoryById404 | GetHistoryById500>>(
 historyId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getHistoryById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHistoryById>>,
          TError,
          Awaited<ReturnType<typeof getHistoryById>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetHistoryById<TData = Awaited<ReturnType<typeof getHistoryById>>, TError = AxiosError<GetHistoryById404 | GetHistoryById500>>(
 historyId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getHistoryById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHistoryById>>,
          TError,
          Awaited<ReturnType<typeof getHistoryById>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetHistoryById<TData = Awaited<ReturnType<typeof getHistoryById>>, TError = AxiosError<GetHistoryById404 | GetHistoryById500>>(
 historyId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getHistoryById>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary æ ¹æ“šæ­·å²è¨˜éŒ„ ID æŸ¥è©¢
 */

export function useGetHistoryById<TData = Awaited<ReturnType<typeof getHistoryById>>, TError = AxiosError<GetHistoryById404 | GetHistoryById500>>(
 historyId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getHistoryById>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetHistoryByIdQueryOptions(historyId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * æ ¹æ“šä½¿ç”¨è€… ID æŸ¥è©¢è©²ä½¿ç”¨è€…çš„æ‰€æœ‰é¡å‹æ­·å²è¨˜éŒ„
 * @summary æŸ¥è©¢ä½¿ç”¨è€…æ‰€æœ‰æ­·å²è¨˜éŒ„
 */
export const getAllHistoriesByUserId = (
    userId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<History>> => {
    
    
    return axios.default.get(
      `/api/history/user/${userId}`,options
    );
  }




export const getGetAllHistoriesByUserIdQueryKey = (userId?: string,) => {
    return [
    `/api/history/user/${userId}`
    ] as const;
    }

    
export const getGetAllHistoriesByUserIdQueryOptions = <TData = Awaited<ReturnType<typeof getAllHistoriesByUserId>>, TError = AxiosError<GetAllHistoriesByUserId404 | GetAllHistoriesByUserId500>>(userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllHistoriesByUserId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllHistoriesByUserIdQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllHistoriesByUserId>>> = ({ signal }) => getAllHistoriesByUserId(userId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllHistoriesByUserId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllHistoriesByUserIdQueryResult = NonNullable<Awaited<ReturnType<typeof getAllHistoriesByUserId>>>
export type GetAllHistoriesByUserIdQueryError = AxiosError<GetAllHistoriesByUserId404 | GetAllHistoriesByUserId500>


export function useGetAllHistoriesByUserId<TData = Awaited<ReturnType<typeof getAllHistoriesByUserId>>, TError = AxiosError<GetAllHistoriesByUserId404 | GetAllHistoriesByUserId500>>(
 userId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllHistoriesByUserId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllHistoriesByUserId>>,
          TError,
          Awaited<ReturnType<typeof getAllHistoriesByUserId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllHistoriesByUserId<TData = Awaited<ReturnType<typeof getAllHistoriesByUserId>>, TError = AxiosError<GetAllHistoriesByUserId404 | GetAllHistoriesByUserId500>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllHistoriesByUserId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllHistoriesByUserId>>,
          TError,
          Awaited<ReturnType<typeof getAllHistoriesByUserId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllHistoriesByUserId<TData = Awaited<ReturnType<typeof getAllHistoriesByUserId>>, TError = AxiosError<GetAllHistoriesByUserId404 | GetAllHistoriesByUserId500>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllHistoriesByUserId>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary æŸ¥è©¢ä½¿ç”¨è€…æ‰€æœ‰æ­·å²è¨˜éŒ„
 */

export function useGetAllHistoriesByUserId<TData = Awaited<ReturnType<typeof getAllHistoriesByUserId>>, TError = AxiosError<GetAllHistoriesByUserId404 | GetAllHistoriesByUserId500>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllHistoriesByUserId>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllHistoriesByUserIdQueryOptions(userId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * æ ¹æ“šå•†å“ ID æœå°‹æ‰€æœ‰é¡å‹çš„æ­·å²è¨˜éŒ„ï¼ˆç«¶æ¨™ã€ç€è¦½ã€è³¼è²·ï¼‰
 * @summary æœå°‹å•†å“ç›¸é—œçš„æ‰€æœ‰æ­·å²è¨˜éŒ„
 */
export const searchAllHistoriesByProductId = (
    productId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<History>> => {
    
    
    return axios.default.get(
      `/api/history/search/product/${productId}`,options
    );
  }




export const getSearchAllHistoriesByProductIdQueryKey = (productId?: string,) => {
    return [
    `/api/history/search/product/${productId}`
    ] as const;
    }

    
export const getSearchAllHistoriesByProductIdQueryOptions = <TData = Awaited<ReturnType<typeof searchAllHistoriesByProductId>>, TError = AxiosError<SearchAllHistoriesByProductId404 | SearchAllHistoriesByProductId500>>(productId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchAllHistoriesByProductId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchAllHistoriesByProductIdQueryKey(productId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchAllHistoriesByProductId>>> = ({ signal }) => searchAllHistoriesByProductId(productId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(productId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchAllHistoriesByProductId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SearchAllHistoriesByProductIdQueryResult = NonNullable<Awaited<ReturnType<typeof searchAllHistoriesByProductId>>>
export type SearchAllHistoriesByProductIdQueryError = AxiosError<SearchAllHistoriesByProductId404 | SearchAllHistoriesByProductId500>


export function useSearchAllHistoriesByProductId<TData = Awaited<ReturnType<typeof searchAllHistoriesByProductId>>, TError = AxiosError<SearchAllHistoriesByProductId404 | SearchAllHistoriesByProductId500>>(
 productId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchAllHistoriesByProductId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchAllHistoriesByProductId>>,
          TError,
          Awaited<ReturnType<typeof searchAllHistoriesByProductId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchAllHistoriesByProductId<TData = Awaited<ReturnType<typeof searchAllHistoriesByProductId>>, TError = AxiosError<SearchAllHistoriesByProductId404 | SearchAllHistoriesByProductId500>>(
 productId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchAllHistoriesByProductId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchAllHistoriesByProductId>>,
          TError,
          Awaited<ReturnType<typeof searchAllHistoriesByProductId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchAllHistoriesByProductId<TData = Awaited<ReturnType<typeof searchAllHistoriesByProductId>>, TError = AxiosError<SearchAllHistoriesByProductId404 | SearchAllHistoriesByProductId500>>(
 productId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchAllHistoriesByProductId>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary æœå°‹å•†å“ç›¸é—œçš„æ‰€æœ‰æ­·å²è¨˜éŒ„
 */

export function useSearchAllHistoriesByProductId<TData = Awaited<ReturnType<typeof searchAllHistoriesByProductId>>, TError = AxiosError<SearchAllHistoriesByProductId404 | SearchAllHistoriesByProductId500>>(
 productId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchAllHistoriesByProductId>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSearchAllHistoriesByProductIdQueryOptions(productId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * æ ¹æ“šè©•è«– ID æŸ¥è©¢è©²è©•è«–çš„æ‰€æœ‰æ­·å²è¨˜éŒ„ï¼ˆå‰µå»ºã€ç·¨è¼¯ç­‰ï¼‰
 * @summary æŸ¥è©¢è©•è«–çš„æ­·å²è¨˜éŒ„
 */
export const getReviewHistoriesByReviewId = (
    reviewId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ReviewHistory>> => {
    
    
    return axios.default.get(
      `/api/history/review/${reviewId}`,options
    );
  }




export const getGetReviewHistoriesByReviewIdQueryKey = (reviewId?: string,) => {
    return [
    `/api/history/review/${reviewId}`
    ] as const;
    }

    
export const getGetReviewHistoriesByReviewIdQueryOptions = <TData = Awaited<ReturnType<typeof getReviewHistoriesByReviewId>>, TError = AxiosError<GetReviewHistoriesByReviewId404 | GetReviewHistoriesByReviewId500>>(reviewId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewHistoriesByReviewId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetReviewHistoriesByReviewIdQueryKey(reviewId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getReviewHistoriesByReviewId>>> = ({ signal }) => getReviewHistoriesByReviewId(reviewId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(reviewId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getReviewHistoriesByReviewId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetReviewHistoriesByReviewIdQueryResult = NonNullable<Awaited<ReturnType<typeof getReviewHistoriesByReviewId>>>
export type GetReviewHistoriesByReviewIdQueryError = AxiosError<GetReviewHistoriesByReviewId404 | GetReviewHistoriesByReviewId500>


export function useGetReviewHistoriesByReviewId<TData = Awaited<ReturnType<typeof getReviewHistoriesByReviewId>>, TError = AxiosError<GetReviewHistoriesByReviewId404 | GetReviewHistoriesByReviewId500>>(
 reviewId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewHistoriesByReviewId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReviewHistoriesByReviewId>>,
          TError,
          Awaited<ReturnType<typeof getReviewHistoriesByReviewId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetReviewHistoriesByReviewId<TData = Awaited<ReturnType<typeof getReviewHistoriesByReviewId>>, TError = AxiosError<GetReviewHistoriesByReviewId404 | GetReviewHistoriesByReviewId500>>(
 reviewId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewHistoriesByReviewId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReviewHistoriesByReviewId>>,
          TError,
          Awaited<ReturnType<typeof getReviewHistoriesByReviewId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetReviewHistoriesByReviewId<TData = Awaited<ReturnType<typeof getReviewHistoriesByReviewId>>, TError = AxiosError<GetReviewHistoriesByReviewId404 | GetReviewHistoriesByReviewId500>>(
 reviewId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewHistoriesByReviewId>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary æŸ¥è©¢è©•è«–çš„æ­·å²è¨˜éŒ„
 */

export function useGetReviewHistoriesByReviewId<TData = Awaited<ReturnType<typeof getReviewHistoriesByReviewId>>, TError = AxiosError<GetReviewHistoriesByReviewId404 | GetReviewHistoriesByReviewId500>>(
 reviewId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewHistoriesByReviewId>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetReviewHistoriesByReviewIdQueryOptions(reviewId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * æ ¹æ“šä½¿ç”¨è€… ID æŸ¥è©¢è©²ä½¿ç”¨è€…çš„æ‰€æœ‰è©•è«–æ­·å²è¨˜éŒ„
 * @summary æŸ¥è©¢ä½¿ç”¨è€…è©•è«–æ­·å²
 */
export const getReviewHistoriesByUserId = (
    userId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ReviewHistory>> => {
    
    
    return axios.default.get(
      `/api/history/review/user/${userId}`,options
    );
  }




export const getGetReviewHistoriesByUserIdQueryKey = (userId?: string,) => {
    return [
    `/api/history/review/user/${userId}`
    ] as const;
    }

    
export const getGetReviewHistoriesByUserIdQueryOptions = <TData = Awaited<ReturnType<typeof getReviewHistoriesByUserId>>, TError = AxiosError<GetReviewHistoriesByUserId404 | GetReviewHistoriesByUserId500>>(userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewHistoriesByUserId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetReviewHistoriesByUserIdQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getReviewHistoriesByUserId>>> = ({ signal }) => getReviewHistoriesByUserId(userId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getReviewHistoriesByUserId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetReviewHistoriesByUserIdQueryResult = NonNullable<Awaited<ReturnType<typeof getReviewHistoriesByUserId>>>
export type GetReviewHistoriesByUserIdQueryError = AxiosError<GetReviewHistoriesByUserId404 | GetReviewHistoriesByUserId500>


export function useGetReviewHistoriesByUserId<TData = Awaited<ReturnType<typeof getReviewHistoriesByUserId>>, TError = AxiosError<GetReviewHistoriesByUserId404 | GetReviewHistoriesByUserId500>>(
 userId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewHistoriesByUserId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReviewHistoriesByUserId>>,
          TError,
          Awaited<ReturnType<typeof getReviewHistoriesByUserId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetReviewHistoriesByUserId<TData = Awaited<ReturnType<typeof getReviewHistoriesByUserId>>, TError = AxiosError<GetReviewHistoriesByUserId404 | GetReviewHistoriesByUserId500>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewHistoriesByUserId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getReviewHistoriesByUserId>>,
          TError,
          Awaited<ReturnType<typeof getReviewHistoriesByUserId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetReviewHistoriesByUserId<TData = Awaited<ReturnType<typeof getReviewHistoriesByUserId>>, TError = AxiosError<GetReviewHistoriesByUserId404 | GetReviewHistoriesByUserId500>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewHistoriesByUserId>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary æŸ¥è©¢ä½¿ç”¨è€…è©•è«–æ­·å²
 */

export function useGetReviewHistoriesByUserId<TData = Awaited<ReturnType<typeof getReviewHistoriesByUserId>>, TError = AxiosError<GetReviewHistoriesByUserId404 | GetReviewHistoriesByUserId500>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getReviewHistoriesByUserId>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetReviewHistoriesByUserIdQueryOptions(userId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * æ ¹æ“šä½¿ç”¨è€… ID æŸ¥è©¢è©²ä½¿ç”¨è€…çš„æ‰€æœ‰è³¼è²·æ­·å²è¨˜éŒ„
 * @summary æŸ¥è©¢ä½¿ç”¨è€…è³¼è²·æ­·å²
 */
export const getPurchaseHistoriesByUserId = (
    userId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PurchaseHistory>> => {
    
    
    return axios.default.get(
      `/api/history/purchase/user/${userId}`,options
    );
  }




export const getGetPurchaseHistoriesByUserIdQueryKey = (userId?: string,) => {
    return [
    `/api/history/purchase/user/${userId}`
    ] as const;
    }

    
export const getGetPurchaseHistoriesByUserIdQueryOptions = <TData = Awaited<ReturnType<typeof getPurchaseHistoriesByUserId>>, TError = AxiosError<GetPurchaseHistoriesByUserId404 | GetPurchaseHistoriesByUserId500>>(userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPurchaseHistoriesByUserId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPurchaseHistoriesByUserIdQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPurchaseHistoriesByUserId>>> = ({ signal }) => getPurchaseHistoriesByUserId(userId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPurchaseHistoriesByUserId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPurchaseHistoriesByUserIdQueryResult = NonNullable<Awaited<ReturnType<typeof getPurchaseHistoriesByUserId>>>
export type GetPurchaseHistoriesByUserIdQueryError = AxiosError<GetPurchaseHistoriesByUserId404 | GetPurchaseHistoriesByUserId500>


export function useGetPurchaseHistoriesByUserId<TData = Awaited<ReturnType<typeof getPurchaseHistoriesByUserId>>, TError = AxiosError<GetPurchaseHistoriesByUserId404 | GetPurchaseHistoriesByUserId500>>(
 userId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPurchaseHistoriesByUserId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPurchaseHistoriesByUserId>>,
          TError,
          Awaited<ReturnType<typeof getPurchaseHistoriesByUserId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPurchaseHistoriesByUserId<TData = Awaited<ReturnType<typeof getPurchaseHistoriesByUserId>>, TError = AxiosError<GetPurchaseHistoriesByUserId404 | GetPurchaseHistoriesByUserId500>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPurchaseHistoriesByUserId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPurchaseHistoriesByUserId>>,
          TError,
          Awaited<ReturnType<typeof getPurchaseHistoriesByUserId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPurchaseHistoriesByUserId<TData = Awaited<ReturnType<typeof getPurchaseHistoriesByUserId>>, TError = AxiosError<GetPurchaseHistoriesByUserId404 | GetPurchaseHistoriesByUserId500>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPurchaseHistoriesByUserId>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary æŸ¥è©¢ä½¿ç”¨è€…è³¼è²·æ­·å²
 */

export function useGetPurchaseHistoriesByUserId<TData = Awaited<ReturnType<typeof getPurchaseHistoriesByUserId>>, TError = AxiosError<GetPurchaseHistoriesByUserId404 | GetPurchaseHistoriesByUserId500>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPurchaseHistoriesByUserId>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPurchaseHistoriesByUserIdQueryOptions(userId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * æ ¹æ“šå•†å“ ID æŸ¥è©¢åŒ…å«è©²å•†å“çš„æ‰€æœ‰è³¼è²·æ­·å²è¨˜éŒ„
 * @summary æŸ¥è©¢å•†å“è³¼è²·æ­·å²
 */
export const getPurchaseHistoriesByProductId = (
    productId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PurchaseHistory>> => {
    
    
    return axios.default.get(
      `/api/history/purchase/product/${productId}`,options
    );
  }




export const getGetPurchaseHistoriesByProductIdQueryKey = (productId?: string,) => {
    return [
    `/api/history/purchase/product/${productId}`
    ] as const;
    }

    
export const getGetPurchaseHistoriesByProductIdQueryOptions = <TData = Awaited<ReturnType<typeof getPurchaseHistoriesByProductId>>, TError = AxiosError<GetPurchaseHistoriesByProductId404 | GetPurchaseHistoriesByProductId500>>(productId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPurchaseHistoriesByProductId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPurchaseHistoriesByProductIdQueryKey(productId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPurchaseHistoriesByProductId>>> = ({ signal }) => getPurchaseHistoriesByProductId(productId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(productId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPurchaseHistoriesByProductId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPurchaseHistoriesByProductIdQueryResult = NonNullable<Awaited<ReturnType<typeof getPurchaseHistoriesByProductId>>>
export type GetPurchaseHistoriesByProductIdQueryError = AxiosError<GetPurchaseHistoriesByProductId404 | GetPurchaseHistoriesByProductId500>


export function useGetPurchaseHistoriesByProductId<TData = Awaited<ReturnType<typeof getPurchaseHistoriesByProductId>>, TError = AxiosError<GetPurchaseHistoriesByProductId404 | GetPurchaseHistoriesByProductId500>>(
 productId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPurchaseHistoriesByProductId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPurchaseHistoriesByProductId>>,
          TError,
          Awaited<ReturnType<typeof getPurchaseHistoriesByProductId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPurchaseHistoriesByProductId<TData = Awaited<ReturnType<typeof getPurchaseHistoriesByProductId>>, TError = AxiosError<GetPurchaseHistoriesByProductId404 | GetPurchaseHistoriesByProductId500>>(
 productId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPurchaseHistoriesByProductId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPurchaseHistoriesByProductId>>,
          TError,
          Awaited<ReturnType<typeof getPurchaseHistoriesByProductId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPurchaseHistoriesByProductId<TData = Awaited<ReturnType<typeof getPurchaseHistoriesByProductId>>, TError = AxiosError<GetPurchaseHistoriesByProductId404 | GetPurchaseHistoriesByProductId500>>(
 productId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPurchaseHistoriesByProductId>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary æŸ¥è©¢å•†å“è³¼è²·æ­·å²
 */

export function useGetPurchaseHistoriesByProductId<TData = Awaited<ReturnType<typeof getPurchaseHistoriesByProductId>>, TError = AxiosError<GetPurchaseHistoriesByProductId404 | GetPurchaseHistoriesByProductId500>>(
 productId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPurchaseHistoriesByProductId>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPurchaseHistoriesByProductIdQueryOptions(productId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * æ ¹æ“šä½¿ç”¨è€… ID æŸ¥è©¢è©²ä½¿ç”¨è€…çš„æ‰€æœ‰ç€è¦½æ­·å²è¨˜éŒ„
 * @summary æŸ¥è©¢ä½¿ç”¨è€…ç€è¦½æ­·å²
 */
export const getBrowseHistoriesByUserId = (
    userId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<BrowseHistory>> => {
    
    
    return axios.default.get(
      `/api/history/browse/user/${userId}`,options
    );
  }




export const getGetBrowseHistoriesByUserIdQueryKey = (userId?: string,) => {
    return [
    `/api/history/browse/user/${userId}`
    ] as const;
    }

    
export const getGetBrowseHistoriesByUserIdQueryOptions = <TData = Awaited<ReturnType<typeof getBrowseHistoriesByUserId>>, TError = AxiosError<GetBrowseHistoriesByUserId404 | GetBrowseHistoriesByUserId500>>(userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBrowseHistoriesByUserId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBrowseHistoriesByUserIdQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBrowseHistoriesByUserId>>> = ({ signal }) => getBrowseHistoriesByUserId(userId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBrowseHistoriesByUserId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBrowseHistoriesByUserIdQueryResult = NonNullable<Awaited<ReturnType<typeof getBrowseHistoriesByUserId>>>
export type GetBrowseHistoriesByUserIdQueryError = AxiosError<GetBrowseHistoriesByUserId404 | GetBrowseHistoriesByUserId500>


export function useGetBrowseHistoriesByUserId<TData = Awaited<ReturnType<typeof getBrowseHistoriesByUserId>>, TError = AxiosError<GetBrowseHistoriesByUserId404 | GetBrowseHistoriesByUserId500>>(
 userId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBrowseHistoriesByUserId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBrowseHistoriesByUserId>>,
          TError,
          Awaited<ReturnType<typeof getBrowseHistoriesByUserId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBrowseHistoriesByUserId<TData = Awaited<ReturnType<typeof getBrowseHistoriesByUserId>>, TError = AxiosError<GetBrowseHistoriesByUserId404 | GetBrowseHistoriesByUserId500>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBrowseHistoriesByUserId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBrowseHistoriesByUserId>>,
          TError,
          Awaited<ReturnType<typeof getBrowseHistoriesByUserId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBrowseHistoriesByUserId<TData = Awaited<ReturnType<typeof getBrowseHistoriesByUserId>>, TError = AxiosError<GetBrowseHistoriesByUserId404 | GetBrowseHistoriesByUserId500>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBrowseHistoriesByUserId>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary æŸ¥è©¢ä½¿ç”¨è€…ç€è¦½æ­·å²
 */

export function useGetBrowseHistoriesByUserId<TData = Awaited<ReturnType<typeof getBrowseHistoriesByUserId>>, TError = AxiosError<GetBrowseHistoriesByUserId404 | GetBrowseHistoriesByUserId500>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBrowseHistoriesByUserId>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBrowseHistoriesByUserIdQueryOptions(userId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * æ ¹æ“šå•†å“ ID æŸ¥è©¢è©²å•†å“çš„æ‰€æœ‰ç€è¦½æ­·å²è¨˜éŒ„
 * @summary æŸ¥è©¢å•†å“ç€è¦½æ­·å²
 */
export const getBrowseHistoriesByProductId = (
    productId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<BrowseHistory>> => {
    
    
    return axios.default.get(
      `/api/history/browse/product/${productId}`,options
    );
  }




export const getGetBrowseHistoriesByProductIdQueryKey = (productId?: string,) => {
    return [
    `/api/history/browse/product/${productId}`
    ] as const;
    }

    
export const getGetBrowseHistoriesByProductIdQueryOptions = <TData = Awaited<ReturnType<typeof getBrowseHistoriesByProductId>>, TError = AxiosError<GetBrowseHistoriesByProductId404 | GetBrowseHistoriesByProductId500>>(productId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBrowseHistoriesByProductId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBrowseHistoriesByProductIdQueryKey(productId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBrowseHistoriesByProductId>>> = ({ signal }) => getBrowseHistoriesByProductId(productId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(productId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBrowseHistoriesByProductId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBrowseHistoriesByProductIdQueryResult = NonNullable<Awaited<ReturnType<typeof getBrowseHistoriesByProductId>>>
export type GetBrowseHistoriesByProductIdQueryError = AxiosError<GetBrowseHistoriesByProductId404 | GetBrowseHistoriesByProductId500>


export function useGetBrowseHistoriesByProductId<TData = Awaited<ReturnType<typeof getBrowseHistoriesByProductId>>, TError = AxiosError<GetBrowseHistoriesByProductId404 | GetBrowseHistoriesByProductId500>>(
 productId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBrowseHistoriesByProductId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBrowseHistoriesByProductId>>,
          TError,
          Awaited<ReturnType<typeof getBrowseHistoriesByProductId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBrowseHistoriesByProductId<TData = Awaited<ReturnType<typeof getBrowseHistoriesByProductId>>, TError = AxiosError<GetBrowseHistoriesByProductId404 | GetBrowseHistoriesByProductId500>>(
 productId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBrowseHistoriesByProductId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBrowseHistoriesByProductId>>,
          TError,
          Awaited<ReturnType<typeof getBrowseHistoriesByProductId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBrowseHistoriesByProductId<TData = Awaited<ReturnType<typeof getBrowseHistoriesByProductId>>, TError = AxiosError<GetBrowseHistoriesByProductId404 | GetBrowseHistoriesByProductId500>>(
 productId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBrowseHistoriesByProductId>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary æŸ¥è©¢å•†å“ç€è¦½æ­·å²
 */

export function useGetBrowseHistoriesByProductId<TData = Awaited<ReturnType<typeof getBrowseHistoriesByProductId>>, TError = AxiosError<GetBrowseHistoriesByProductId404 | GetBrowseHistoriesByProductId500>>(
 productId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBrowseHistoriesByProductId>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBrowseHistoriesByProductIdQueryOptions(productId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * æ ¹æ“šä½¿ç”¨è€… ID æŸ¥è©¢è©²ä½¿ç”¨è€…çš„æ‰€æœ‰ç«¶æ¨™æ­·å²è¨˜éŒ„
 * @summary æŸ¥è©¢ä½¿ç”¨è€…ç«¶æ¨™æ­·å²
 */
export const getBidHistoriesByUserId = (
    userId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<BidHistory>> => {
    
    
    return axios.default.get(
      `/api/history/bid/user/${userId}`,options
    );
  }




export const getGetBidHistoriesByUserIdQueryKey = (userId?: string,) => {
    return [
    `/api/history/bid/user/${userId}`
    ] as const;
    }

    
export const getGetBidHistoriesByUserIdQueryOptions = <TData = Awaited<ReturnType<typeof getBidHistoriesByUserId>>, TError = AxiosError<GetBidHistoriesByUserId404 | GetBidHistoriesByUserId500>>(userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBidHistoriesByUserId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBidHistoriesByUserIdQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBidHistoriesByUserId>>> = ({ signal }) => getBidHistoriesByUserId(userId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBidHistoriesByUserId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBidHistoriesByUserIdQueryResult = NonNullable<Awaited<ReturnType<typeof getBidHistoriesByUserId>>>
export type GetBidHistoriesByUserIdQueryError = AxiosError<GetBidHistoriesByUserId404 | GetBidHistoriesByUserId500>


export function useGetBidHistoriesByUserId<TData = Awaited<ReturnType<typeof getBidHistoriesByUserId>>, TError = AxiosError<GetBidHistoriesByUserId404 | GetBidHistoriesByUserId500>>(
 userId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBidHistoriesByUserId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBidHistoriesByUserId>>,
          TError,
          Awaited<ReturnType<typeof getBidHistoriesByUserId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBidHistoriesByUserId<TData = Awaited<ReturnType<typeof getBidHistoriesByUserId>>, TError = AxiosError<GetBidHistoriesByUserId404 | GetBidHistoriesByUserId500>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBidHistoriesByUserId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBidHistoriesByUserId>>,
          TError,
          Awaited<ReturnType<typeof getBidHistoriesByUserId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBidHistoriesByUserId<TData = Awaited<ReturnType<typeof getBidHistoriesByUserId>>, TError = AxiosError<GetBidHistoriesByUserId404 | GetBidHistoriesByUserId500>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBidHistoriesByUserId>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary æŸ¥è©¢ä½¿ç”¨è€…ç«¶æ¨™æ­·å²
 */

export function useGetBidHistoriesByUserId<TData = Awaited<ReturnType<typeof getBidHistoriesByUserId>>, TError = AxiosError<GetBidHistoriesByUserId404 | GetBidHistoriesByUserId500>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBidHistoriesByUserId>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBidHistoriesByUserIdQueryOptions(userId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * æ ¹æ“šå•†å“ ID æŸ¥è©¢è©²å•†å“çš„æ‰€æœ‰ç«¶æ¨™æ­·å²è¨˜éŒ„
 * @summary æŸ¥è©¢å•†å“ç«¶æ¨™æ­·å²
 */
export const getBidHistoriesByProductId = (
    productId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<BidHistory>> => {
    
    
    return axios.default.get(
      `/api/history/bid/product/${productId}`,options
    );
  }




export const getGetBidHistoriesByProductIdQueryKey = (productId?: string,) => {
    return [
    `/api/history/bid/product/${productId}`
    ] as const;
    }

    
export const getGetBidHistoriesByProductIdQueryOptions = <TData = Awaited<ReturnType<typeof getBidHistoriesByProductId>>, TError = AxiosError<GetBidHistoriesByProductId404 | GetBidHistoriesByProductId500>>(productId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBidHistoriesByProductId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBidHistoriesByProductIdQueryKey(productId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBidHistoriesByProductId>>> = ({ signal }) => getBidHistoriesByProductId(productId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(productId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBidHistoriesByProductId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBidHistoriesByProductIdQueryResult = NonNullable<Awaited<ReturnType<typeof getBidHistoriesByProductId>>>
export type GetBidHistoriesByProductIdQueryError = AxiosError<GetBidHistoriesByProductId404 | GetBidHistoriesByProductId500>


export function useGetBidHistoriesByProductId<TData = Awaited<ReturnType<typeof getBidHistoriesByProductId>>, TError = AxiosError<GetBidHistoriesByProductId404 | GetBidHistoriesByProductId500>>(
 productId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBidHistoriesByProductId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBidHistoriesByProductId>>,
          TError,
          Awaited<ReturnType<typeof getBidHistoriesByProductId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBidHistoriesByProductId<TData = Awaited<ReturnType<typeof getBidHistoriesByProductId>>, TError = AxiosError<GetBidHistoriesByProductId404 | GetBidHistoriesByProductId500>>(
 productId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBidHistoriesByProductId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBidHistoriesByProductId>>,
          TError,
          Awaited<ReturnType<typeof getBidHistoriesByProductId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBidHistoriesByProductId<TData = Awaited<ReturnType<typeof getBidHistoriesByProductId>>, TError = AxiosError<GetBidHistoriesByProductId404 | GetBidHistoriesByProductId500>>(
 productId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBidHistoriesByProductId>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary æŸ¥è©¢å•†å“ç«¶æ¨™æ­·å²
 */

export function useGetBidHistoriesByProductId<TData = Awaited<ReturnType<typeof getBidHistoriesByProductId>>, TError = AxiosError<GetBidHistoriesByProductId404 | GetBidHistoriesByProductId500>>(
 productId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBidHistoriesByProductId>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBidHistoriesByProductIdQueryOptions(productId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * å–å¾—æŒ‡å®šä½¿ç”¨è€…çš„å®Œæ•´æ”¶è—æ¸…å–®ï¼ˆåŒ…å«å•†å“è©³ç´°è³‡è¨Šã€è³£å®¶è³‡è¨Šï¼‰ï¼Œè‡ªå‹•éæ¿¾å·²åˆªé™¤çš„å•†å“
 * @summary ã€READã€‘å–å¾—ä½¿ç”¨è€…æ”¶è—æ¸…å–®
 */
export const getUserFavorites = (
    userId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<FavoriteResponseDTO>> => {
    
    
    return axios.default.get(
      `/api/favorites/${userId}`,options
    );
  }




export const getGetUserFavoritesQueryKey = (userId?: string,) => {
    return [
    `/api/favorites/${userId}`
    ] as const;
    }

    
export const getGetUserFavoritesQueryOptions = <TData = Awaited<ReturnType<typeof getUserFavorites>>, TError = AxiosError<FavoriteResponseDTO>>(userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFavorites>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserFavoritesQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserFavorites>>> = ({ signal }) => getUserFavorites(userId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserFavorites>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserFavoritesQueryResult = NonNullable<Awaited<ReturnType<typeof getUserFavorites>>>
export type GetUserFavoritesQueryError = AxiosError<FavoriteResponseDTO>


export function useGetUserFavorites<TData = Awaited<ReturnType<typeof getUserFavorites>>, TError = AxiosError<FavoriteResponseDTO>>(
 userId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFavorites>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserFavorites>>,
          TError,
          Awaited<ReturnType<typeof getUserFavorites>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserFavorites<TData = Awaited<ReturnType<typeof getUserFavorites>>, TError = AxiosError<FavoriteResponseDTO>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFavorites>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserFavorites>>,
          TError,
          Awaited<ReturnType<typeof getUserFavorites>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserFavorites<TData = Awaited<ReturnType<typeof getUserFavorites>>, TError = AxiosError<FavoriteResponseDTO>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFavorites>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ã€READã€‘å–å¾—ä½¿ç”¨è€…æ”¶è—æ¸…å–®
 */

export function useGetUserFavorites<TData = Awaited<ReturnType<typeof getUserFavorites>>, TError = AxiosError<FavoriteResponseDTO>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFavorites>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserFavoritesQueryOptions(userId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * æ¸…ç©ºä½¿ç”¨è€…çš„æ‰€æœ‰æ”¶è—
 * @summary ã€DELETEã€‘æ¸…ç©ºæ”¶è—æ¸…å–®
 */
export const clearFavorites = (
    userId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.delete(
      `/api/favorites/${userId}`,options
    );
  }



export const getClearFavoritesMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof clearFavorites>>, TError,{userId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof clearFavorites>>, TError,{userId: string}, TContext> => {

const mutationKey = ['clearFavorites'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof clearFavorites>>, {userId: string}> = (props) => {
          const {userId} = props ?? {};

          return  clearFavorites(userId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ClearFavoritesMutationResult = NonNullable<Awaited<ReturnType<typeof clearFavorites>>>
    
    export type ClearFavoritesMutationError = AxiosError<unknown>

    /**
 * @summary ã€DELETEã€‘æ¸…ç©ºæ”¶è—æ¸…å–®
 */
export const useClearFavorites = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof clearFavorites>>, TError,{userId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof clearFavorites>>,
        TError,
        {userId: string},
        TContext
      > => {

      const mutationOptions = getClearFavoritesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * åªå›å‚³å•†å“ ID å’ŒåŠ å…¥æ™‚é–“ï¼Œä¸æŸ¥è©¢å•†å“è©³ç´°è³‡è¨Šã€‚é©åˆç”¨æ–¼å¿«é€Ÿæª¢æŸ¥æ”¶è—ç‹€æ…‹æˆ–å‰ç«¯å¿«å–ã€‚
 * @summary ã€READã€‘å–å¾—ä½¿ç”¨è€…æ”¶è—æ¸…å–®ï¼ˆç°¡åŒ–ç‰ˆï¼‰
 */
export const getSimpleUserFavorites = (
    userId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SimpleFavoriteResponseDTO>> => {
    
    
    return axios.default.get(
      `/api/favorites/${userId}/simple`,options
    );
  }




export const getGetSimpleUserFavoritesQueryKey = (userId?: string,) => {
    return [
    `/api/favorites/${userId}/simple`
    ] as const;
    }

    
export const getGetSimpleUserFavoritesQueryOptions = <TData = Awaited<ReturnType<typeof getSimpleUserFavorites>>, TError = AxiosError<SimpleFavoriteResponseDTO>>(userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSimpleUserFavorites>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSimpleUserFavoritesQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSimpleUserFavorites>>> = ({ signal }) => getSimpleUserFavorites(userId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSimpleUserFavorites>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSimpleUserFavoritesQueryResult = NonNullable<Awaited<ReturnType<typeof getSimpleUserFavorites>>>
export type GetSimpleUserFavoritesQueryError = AxiosError<SimpleFavoriteResponseDTO>


export function useGetSimpleUserFavorites<TData = Awaited<ReturnType<typeof getSimpleUserFavorites>>, TError = AxiosError<SimpleFavoriteResponseDTO>>(
 userId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSimpleUserFavorites>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSimpleUserFavorites>>,
          TError,
          Awaited<ReturnType<typeof getSimpleUserFavorites>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSimpleUserFavorites<TData = Awaited<ReturnType<typeof getSimpleUserFavorites>>, TError = AxiosError<SimpleFavoriteResponseDTO>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSimpleUserFavorites>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSimpleUserFavorites>>,
          TError,
          Awaited<ReturnType<typeof getSimpleUserFavorites>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSimpleUserFavorites<TData = Awaited<ReturnType<typeof getSimpleUserFavorites>>, TError = AxiosError<SimpleFavoriteResponseDTO>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSimpleUserFavorites>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ã€READã€‘å–å¾—ä½¿ç”¨è€…æ”¶è—æ¸…å–®ï¼ˆç°¡åŒ–ç‰ˆï¼‰
 */

export function useGetSimpleUserFavorites<TData = Awaited<ReturnType<typeof getSimpleUserFavorites>>, TError = AxiosError<SimpleFavoriteResponseDTO>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSimpleUserFavorites>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSimpleUserFavoritesQueryOptions(userId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * å–å¾—ä½¿ç”¨è€…çš„æ”¶è—å•†å“ç¸½æ•¸ï¼Œå¯ç”¨æ–¼é¡¯ç¤ºæ”¶è—å¾½ç« 
 * @summary ã€READã€‘å–å¾—æ”¶è—æ•¸é‡
 */
export const getFavoritesCount = (
    userId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.get(
      `/api/favorites/${userId}/count`,options
    );
  }




export const getGetFavoritesCountQueryKey = (userId?: string,) => {
    return [
    `/api/favorites/${userId}/count`
    ] as const;
    }

    
export const getGetFavoritesCountQueryOptions = <TData = Awaited<ReturnType<typeof getFavoritesCount>>, TError = AxiosError<unknown>>(userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFavoritesCount>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFavoritesCountQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFavoritesCount>>> = ({ signal }) => getFavoritesCount(userId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getFavoritesCount>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetFavoritesCountQueryResult = NonNullable<Awaited<ReturnType<typeof getFavoritesCount>>>
export type GetFavoritesCountQueryError = AxiosError<unknown>


export function useGetFavoritesCount<TData = Awaited<ReturnType<typeof getFavoritesCount>>, TError = AxiosError<unknown>>(
 userId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFavoritesCount>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFavoritesCount>>,
          TError,
          Awaited<ReturnType<typeof getFavoritesCount>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFavoritesCount<TData = Awaited<ReturnType<typeof getFavoritesCount>>, TError = AxiosError<unknown>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFavoritesCount>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFavoritesCount>>,
          TError,
          Awaited<ReturnType<typeof getFavoritesCount>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFavoritesCount<TData = Awaited<ReturnType<typeof getFavoritesCount>>, TError = AxiosError<unknown>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFavoritesCount>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ã€READã€‘å–å¾—æ”¶è—æ•¸é‡
 */

export function useGetFavoritesCount<TData = Awaited<ReturnType<typeof getFavoritesCount>>, TError = AxiosError<unknown>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFavoritesCount>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetFavoritesCountQueryOptions(userId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * æª¢æŸ¥æŒ‡å®šå•†å“æ˜¯å¦åœ¨ä½¿ç”¨è€…çš„æ”¶è—æ¸…å–®ä¸­ï¼Œå¸¸ç”¨æ–¼å•†å“é é¢é¡¯ç¤ºã€Œå·²æ”¶è—ã€ç‹€æ…‹
 * @summary ã€READã€‘æª¢æŸ¥æ˜¯å¦å·²æ”¶è—
 */
export const isFavorited = (
    userId: string,
    productId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.get(
      `/api/favorites/${userId}/check/${productId}`,options
    );
  }




export const getIsFavoritedQueryKey = (userId?: string,
    productId?: string,) => {
    return [
    `/api/favorites/${userId}/check/${productId}`
    ] as const;
    }

    
export const getIsFavoritedQueryOptions = <TData = Awaited<ReturnType<typeof isFavorited>>, TError = AxiosError<unknown>>(userId: string,
    productId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof isFavorited>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getIsFavoritedQueryKey(userId,productId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof isFavorited>>> = ({ signal }) => isFavorited(userId,productId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId && productId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof isFavorited>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type IsFavoritedQueryResult = NonNullable<Awaited<ReturnType<typeof isFavorited>>>
export type IsFavoritedQueryError = AxiosError<unknown>


export function useIsFavorited<TData = Awaited<ReturnType<typeof isFavorited>>, TError = AxiosError<unknown>>(
 userId: string,
    productId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof isFavorited>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof isFavorited>>,
          TError,
          Awaited<ReturnType<typeof isFavorited>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIsFavorited<TData = Awaited<ReturnType<typeof isFavorited>>, TError = AxiosError<unknown>>(
 userId: string,
    productId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof isFavorited>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof isFavorited>>,
          TError,
          Awaited<ReturnType<typeof isFavorited>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIsFavorited<TData = Awaited<ReturnType<typeof isFavorited>>, TError = AxiosError<unknown>>(
 userId: string,
    productId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof isFavorited>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ã€READã€‘æª¢æŸ¥æ˜¯å¦å·²æ”¶è—
 */

export function useIsFavorited<TData = Awaited<ReturnType<typeof isFavorited>>, TError = AxiosError<unknown>>(
 userId: string,
    productId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof isFavorited>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getIsFavoritedQueryOptions(userId,productId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * è¼¸å…¥ couponID æŸ¥è©¢å„ªæƒ åˆ¸è©³ç´°è³‡æ–™
 * @summary æ ¹æ“š ID æŸ¥è©¢å„ªæƒ åˆ¸
 */
export const getCouponById = (
    couponID: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Coupon>> => {
    
    
    return axios.default.get(
      `/api/coupons/${couponID}`,options
    );
  }




export const getGetCouponByIdQueryKey = (couponID?: string,) => {
    return [
    `/api/coupons/${couponID}`
    ] as const;
    }

    
export const getGetCouponByIdQueryOptions = <TData = Awaited<ReturnType<typeof getCouponById>>, TError = AxiosError<GetCouponById404 | GetCouponById500>>(couponID: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCouponById>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCouponByIdQueryKey(couponID);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCouponById>>> = ({ signal }) => getCouponById(couponID, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(couponID), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCouponById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCouponByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getCouponById>>>
export type GetCouponByIdQueryError = AxiosError<GetCouponById404 | GetCouponById500>


export function useGetCouponById<TData = Awaited<ReturnType<typeof getCouponById>>, TError = AxiosError<GetCouponById404 | GetCouponById500>>(
 couponID: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCouponById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCouponById>>,
          TError,
          Awaited<ReturnType<typeof getCouponById>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCouponById<TData = Awaited<ReturnType<typeof getCouponById>>, TError = AxiosError<GetCouponById404 | GetCouponById500>>(
 couponID: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCouponById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCouponById>>,
          TError,
          Awaited<ReturnType<typeof getCouponById>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCouponById<TData = Awaited<ReturnType<typeof getCouponById>>, TError = AxiosError<GetCouponById404 | GetCouponById500>>(
 couponID: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCouponById>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary æ ¹æ“š ID æŸ¥è©¢å„ªæƒ åˆ¸
 */

export function useGetCouponById<TData = Awaited<ReturnType<typeof getCouponById>>, TError = AxiosError<GetCouponById404 | GetCouponById500>>(
 couponID: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCouponById>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCouponByIdQueryOptions(couponID,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary åˆªé™¤å„ªæƒ åˆ¸
 */
export const deleteCoupon = (
    couponID: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DeleteCoupon200>> => {
    
    
    return axios.default.delete(
      `/api/coupons/${couponID}`,options
    );
  }



export const getDeleteCouponMutationOptions = <TError = AxiosError<DeleteCoupon404 | DeleteCoupon500>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCoupon>>, TError,{couponID: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteCoupon>>, TError,{couponID: string}, TContext> => {

const mutationKey = ['deleteCoupon'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCoupon>>, {couponID: string}> = (props) => {
          const {couponID} = props ?? {};

          return  deleteCoupon(couponID,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteCouponMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCoupon>>>
    
    export type DeleteCouponMutationError = AxiosError<DeleteCoupon404 | DeleteCoupon500>

    /**
 * @summary åˆªé™¤å„ªæƒ åˆ¸
 */
export const useDeleteCoupon = <TError = AxiosError<DeleteCoupon404 | DeleteCoupon500>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCoupon>>, TError,{couponID: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteCoupon>>,
        TError,
        {couponID: string},
        TContext
      > => {

      const mutationOptions = getDeleteCouponMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * å–å¾—ç•¶å‰ç™»å…¥ä½¿ç”¨è€…çš„è³¼ç‰©è»Šï¼ŒåŒ…å«å•†å“å®Œæ•´è³‡è¨Šï¼ˆåç¨±ã€åƒ¹æ ¼ã€åœ–ç‰‡ã€è³£å®¶ç­‰ï¼‰
 * @summary å–å¾—è³¼ç‰©è»Š
 */
export const getCart = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CartResponseDTO>> => {
    
    
    return axios.default.get(
      `/api/cart`,options
    );
  }




export const getGetCartQueryKey = () => {
    return [
    `/api/cart`
    ] as const;
    }

    
export const getGetCartQueryOptions = <TData = Awaited<ReturnType<typeof getCart>>, TError = AxiosError<CartResponseDTO>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCart>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCartQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCart>>> = ({ signal }) => getCart({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCart>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCartQueryResult = NonNullable<Awaited<ReturnType<typeof getCart>>>
export type GetCartQueryError = AxiosError<CartResponseDTO>


export function useGetCart<TData = Awaited<ReturnType<typeof getCart>>, TError = AxiosError<CartResponseDTO>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCart>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCart>>,
          TError,
          Awaited<ReturnType<typeof getCart>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCart<TData = Awaited<ReturnType<typeof getCart>>, TError = AxiosError<CartResponseDTO>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCart>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCart>>,
          TError,
          Awaited<ReturnType<typeof getCart>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCart<TData = Awaited<ReturnType<typeof getCart>>, TError = AxiosError<CartResponseDTO>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCart>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary å–å¾—è³¼ç‰©è»Š
 */

export function useGetCart<TData = Awaited<ReturnType<typeof getCart>>, TError = AxiosError<CartResponseDTO>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCart>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCartQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * æ¸…ç©ºç•¶å‰ä½¿ç”¨è€…çš„è³¼ç‰©è»Šï¼Œç§»é™¤æ‰€æœ‰å•†å“
 * @summary æ¸…ç©ºè³¼ç‰©è»Š
 */
export const clearCart = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.delete(
      `/api/cart`,options
    );
  }



export const getClearCartMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof clearCart>>, TError,void, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof clearCart>>, TError,void, TContext> => {

const mutationKey = ['clearCart'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof clearCart>>, void> = () => {
          

          return  clearCart(axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ClearCartMutationResult = NonNullable<Awaited<ReturnType<typeof clearCart>>>
    
    export type ClearCartMutationError = AxiosError<void>

    /**
 * @summary æ¸…ç©ºè³¼ç‰©è»Š
 */
export const useClearCart = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof clearCart>>, TError,void, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof clearCart>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getClearCartMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * æ ¹æ“šé—œéµå­—é€²è¡Œæ¨¡ç³Šæœå°‹ï¼Œå¯æœå°‹å•†å“åç¨±ã€æè¿°ç­‰ç›¸é—œå…§å®¹
 * @summary æ¨¡ç³Šæœå°‹å•†å“
 */
export const blursearch = (
    params: BlursearchParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Product>> => {
    
    
    return axios.default.get(
      `/api/blursearch`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getBlursearchQueryKey = (params?: BlursearchParams,) => {
    return [
    `/api/blursearch`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getBlursearchQueryOptions = <TData = Awaited<ReturnType<typeof blursearch>>, TError = AxiosError<unknown>>(params: BlursearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof blursearch>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBlursearchQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof blursearch>>> = ({ signal }) => blursearch(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof blursearch>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type BlursearchQueryResult = NonNullable<Awaited<ReturnType<typeof blursearch>>>
export type BlursearchQueryError = AxiosError<unknown>


export function useBlursearch<TData = Awaited<ReturnType<typeof blursearch>>, TError = AxiosError<unknown>>(
 params: BlursearchParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof blursearch>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof blursearch>>,
          TError,
          Awaited<ReturnType<typeof blursearch>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBlursearch<TData = Awaited<ReturnType<typeof blursearch>>, TError = AxiosError<unknown>>(
 params: BlursearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof blursearch>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof blursearch>>,
          TError,
          Awaited<ReturnType<typeof blursearch>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBlursearch<TData = Awaited<ReturnType<typeof blursearch>>, TError = AxiosError<unknown>>(
 params: BlursearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof blursearch>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary æ¨¡ç³Šæœå°‹å•†å“
 */

export function useBlursearch<TData = Awaited<ReturnType<typeof blursearch>>, TError = AxiosError<unknown>>(
 params: BlursearchParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof blursearch>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getBlursearchQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * æŸ¥è©¢æ‰€æœ‰æ­£åœ¨é€²è¡Œæ‹è³£çš„å•†å“åˆ—è¡¨
 * @summary å–å¾—æ‰€æœ‰æ‹è³£ä¸­çš„å•†å“
 */
export const getAllAuctionProduct = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.get(
      `/api/auctions/`,options
    );
  }




export const getGetAllAuctionProductQueryKey = () => {
    return [
    `/api/auctions/`
    ] as const;
    }

    
export const getGetAllAuctionProductQueryOptions = <TData = Awaited<ReturnType<typeof getAllAuctionProduct>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllAuctionProduct>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllAuctionProductQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllAuctionProduct>>> = ({ signal }) => getAllAuctionProduct({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllAuctionProduct>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllAuctionProductQueryResult = NonNullable<Awaited<ReturnType<typeof getAllAuctionProduct>>>
export type GetAllAuctionProductQueryError = AxiosError<unknown>


export function useGetAllAuctionProduct<TData = Awaited<ReturnType<typeof getAllAuctionProduct>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllAuctionProduct>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllAuctionProduct>>,
          TError,
          Awaited<ReturnType<typeof getAllAuctionProduct>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllAuctionProduct<TData = Awaited<ReturnType<typeof getAllAuctionProduct>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllAuctionProduct>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllAuctionProduct>>,
          TError,
          Awaited<ReturnType<typeof getAllAuctionProduct>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllAuctionProduct<TData = Awaited<ReturnType<typeof getAllAuctionProduct>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllAuctionProduct>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary å–å¾—æ‰€æœ‰æ‹è³£ä¸­çš„å•†å“
 */

export function useGetAllAuctionProduct<TData = Awaited<ReturnType<typeof getAllAuctionProduct>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllAuctionProduct>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllAuctionProductQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * @summary åˆªé™¤ä½¿ç”¨è€…å„ªæƒ åˆ¸
 */
export const deleteUserCoupon = (
    userCouponId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DeleteUserCoupon200>> => {
    
    
    return axios.default.delete(
      `/api/userCoupon/${userCouponId}`,options
    );
  }



export const getDeleteUserCouponMutationOptions = <TError = AxiosError<DeleteUserCoupon403 | DeleteUserCoupon404>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUserCoupon>>, TError,{userCouponId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteUserCoupon>>, TError,{userCouponId: string}, TContext> => {

const mutationKey = ['deleteUserCoupon'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUserCoupon>>, {userCouponId: string}> = (props) => {
          const {userCouponId} = props ?? {};

          return  deleteUserCoupon(userCouponId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteUserCouponMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUserCoupon>>>
    
    export type DeleteUserCouponMutationError = AxiosError<DeleteUserCoupon403 | DeleteUserCoupon404>

    /**
 * @summary åˆªé™¤ä½¿ç”¨è€…å„ªæƒ åˆ¸
 */
export const useDeleteUserCoupon = <TError = AxiosError<DeleteUserCoupon403 | DeleteUserCoupon404>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUserCoupon>>, TError,{userCouponId: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteUserCoupon>>,
        TError,
        {userCouponId: string},
        TContext
      > => {

      const mutationOptions = getDeleteUserCouponMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * æ°¸ä¹…åˆªé™¤å•†å“è³‡æ–™
 * @summary åˆªé™¤å•†å“
 */
export const deleteProduct = (
    productID: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.default.delete(
      `/api/products/delete/${productID}`,options
    );
  }



export const getDeleteProductMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteProduct>>, TError,{productID: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteProduct>>, TError,{productID: string}, TContext> => {

const mutationKey = ['deleteProduct'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteProduct>>, {productID: string}> = (props) => {
          const {productID} = props ?? {};

          return  deleteProduct(productID,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteProductMutationResult = NonNullable<Awaited<ReturnType<typeof deleteProduct>>>
    
    export type DeleteProductMutationError = AxiosError<unknown>

    /**
 * @summary åˆªé™¤å•†å“
 */
export const useDeleteProduct = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteProduct>>, TError,{productID: string}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteProduct>>,
        TError,
        {productID: string},
        TContext
      > => {

      const mutationOptions = getDeleteProductMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
